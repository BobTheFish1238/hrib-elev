<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1024, initial-scale=1.0">
    <title>HribHabitat</title>
	<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512' width='512' height='512'%3E%3C!-- Cap --%3E%3Cdefs%3E%3CradialGradient id='capGradient' cx='50%25' cy='35%25' r='60%25'%3E%3Cstop offset='0%25' stop-color='%238b4513'/%3E%3Cstop offset='100%25' stop-color='%235a2d0c'/%3E%3C/radialGradient%3E%3ClinearGradient id='stemGradient' x1='0' y1='0' x2='0' y2='1'%3E%3Cstop offset='0%25' stop-color='%23f6e6c8'/%3E%3Cstop offset='100%25' stop-color='%23d2b48c'/%3E%3C/linearGradient%3E%3C/defs%3E%3C!-- Cap --%3E%3Cpath d=' M96 220 C110 140, 200 110, 256 110 C312 110, 402 140, 416 220 C420 250, 390 270, 256 270 C122 270, 92 250, 96 220 Z' fill='url(%23capGradient)' /%3E%3C!-- Cap underside --%3E%3Cellipse cx='256' cy='255' rx='150' ry='22' fill='%23e8d6b0' /%3E%3C!-- Stem --%3E%3Cpath d=' M200 270 C190 330, 190 390, 210 430 C230 465, 282 465, 302 430 C322 390, 322 330, 312 270 Z' fill='url(%23stemGradient)' /%3E%3C!-- Stem texture --%3E%3Cg fill='%23c9a877' opacity='0.7'%3E%3Cellipse cx='240' cy='310' rx='4' ry='8'/%3E%3Cellipse cx='270' cy='330' rx='5' ry='10'/%3E%3Cellipse cx='255' cy='360' rx='4' ry='9'/%3E%3Cellipse cx='235' cy='385' rx='3' ry='7'/%3E%3Cellipse cx='275' cy='395' rx='4' ry='8'/%3E%3C/g%3E%3C/svg%3E%0A">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 20px 80px 20px 80px;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #8B4513;
        }
        
        h1 {
            color: #8B4513;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            font-style: italic;
        }
        
        .description {
            background-color: #fff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            border-left: 4px solid #8B4513;
			font-size: 14px;
        }
        
        .main-container {
            display: block;
            grid-template-columns: 300px 1fr;
            gap: 25px;
        }
        
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
        
        .content-container {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1200px) {
            .content-container {
                grid-template-columns: 1fr;
            }
        }
        
        .graph-container {
            background-color: #fff;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
			min-height: 500px;
        }
        
        .graph-container:hover {
            transform: translateY(-5px);
        }

        .graph-container:has(#data-table) {
            max-height: none;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #data-table-container {
            overflow-y: auto;
            flex-grow: 1;
            max-height: 430px;
        }
        
        .graph-title {
            color: #8B4513;
            margin-bottom: 15px;
            font-size: 1.4rem;
            text-align: center;
        }
        
		.chart-wrapper canvas#mainChart,
		.chart-wrapper canvas#histogramChart {
			position: relative;
			min-height: 500px;
			width: 100%;
		}

		/* Chart header and controls */
		.chart-header {
			display: flex;
			flex-direction: column;
			margin-bottom: 20px;
		}

		.chart-controls {
			display: flex;
			flex-wrap: wrap;
			gap: 15px;
			margin-top: 10px;
			align-items: center;
			justify-content: center;
		}

		.chart-selector, .axis-selectors {
			display: flex;
			align-items: center;
			gap: 10px;
		}

		.axis-selectors {
			display: flex;
			gap: 20px;
		}

		.axis-selector {
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.chart-selector label, .axis-selector label {
			margin-bottom: 0;
			white-space: nowrap;
			text-align: right;
			font-size: 16px;
			font-weight: 600;
		}

		.chart-selector select, .axis-selector select {
			padding: 8px 12px;
			font-size: 14px;
			border: 1px solid #ddd;
			border-radius: 4px;
			min-width: 150px;
		}

		.histogram-controls {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 10px;
			margin-top: 10px;
			flex-wrap: wrap;
		}

		.histogram-controls select,
		.histogram-controls input[type="number"] {
			padding: 8px 12px;
			font-size: 14px;
			border: 1px solid #ddd;
			border-radius: 4px;
			min-width: 50px;
			max-width: 30%;
		}

		.histogram-controls label {
			font-size: 14px;
			margin-left: 5px;
			white-space: nowrap;
		}

		#histogramChart {
			cursor: pointer;
		}
        
        .input-section {
            background-color: #fff;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        
		.input-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			top: 0;
			z-index: 10;
		}

        .input-title {
            color: #8B4513;
            margin-bottom: 20px;
            font-size: 1.6rem;
        }
        
        .input-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .input-field {
            flex: 1;
            min-width: 200px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }
        
        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #8B4513;
        }
        
        button {
            background-color: #8B4513;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #6B3410;
        }
        
        .map-container {
            height: 600px;
            width: 100%;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 15px;
            border: 1px solid #ddd;
        }
        
        .info-panel {
            background-color: #fff;
            border-radius: 10px;
            padding: 20px;
            margin-top: 25px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            display: none;
        }
        
        .info-panel.active {
            display: block;
        }
        
        .info-title {
            color: #8B4513;
            margin-bottom: 15px;
            font-size: 1.4rem;
            border-bottom: 2px solid #8B4513;
        }
        
        .info-content {
            line-height: 1.8;
        }
        
        .info-item {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .info-label {
            font-weight: 600;
            color: #555;
            display: inline-block;
            width: 275px;
            white-space: nowrap;
        }
        
        .link {
            color: #1a73e8;
            text-decoration: none;
            word-break: break-all;
        }
        
        .link:hover {
            text-decoration: underline;
        }
        
        .user-point {
            background-color: #FF6B6B !important;
            border-color: #FF3838 !important;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 15px;
            color: #8B4513;
            font-weight: 600;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #666;
            font-size: 0.9rem;
        }
        
        /* NDJSON Directory Styles */
		.ndjson-directory {
			background-color: #fff;
			border-radius: 10px;
			padding: 20px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
			height: 100%;
			max-height: 450px;
			overflow-y: auto;
			display: flex;
			flex-direction: column;
		}

		.ndjson-directory,
		.settings-section {
			margin-bottom: 25px;
		}
        
		.directory-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 20px;
			position: sticky;
			top: 0;
			z-index: 10;
		}
        
        .directory-title {
            color: #8B4513;
            font-size: 1.3rem;
            font-weight: 625;
        }
        
		.directory-content {
			flex-grow: 1;
			overflow-y: auto;
		}

		.toggle-btn {
			background: none;
			border: none;
			color: #8B4513;
			font-size: 0.8rem;
			cursor: pointer;
			padding: 5px;
		}
        
        .folder {
            margin-bottom: 15px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #eee;
        }
        
		.directory-controls {
			display: flex;
			gap: 8px;
			margin-left: auto;
		}
		
		.folder-controls {
			display: flex;
			gap: 8px;
			margin-left: 20px;
		}
		
		.control-btn {
			background: none;
			border: 1px solid #8B4513;
			color: #8B4513;
			padding: 4px 8px;
			border-radius: 4px;
			cursor: pointer;
			font-size: 12px;
			font-weight: 600;
			transition: all 0.3s ease;
		}
		
		.control-btn:hover {
			background-color: #8B4513;
			color: white;
		}
		
		.folder-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 5px 10px;
			background-color: #f8f8f8;
			cursor: pointer;
			border-bottom: 1px solid #eee;
			position: relative;
			width: 100%;
		}
        
        .folder-name {
            font-weight: 600;
			font-size: 0.85em;
            color: #555;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
			min-width: 0;
        }

		.folder-count {
			font-size: 11px;
			padding: 1px 5px;
			border-radius: 8px;
			margin-left: 5px;
			flex-shrink: 0;
			white-space: nowrap;
		}
        
        .folder-content {
            padding: 10px;
            background-color: #fff;
            transition: max-height 0.3s ease;
            max-height: 1000px;
            overflow: hidden;
        }
        
        .folder-content.collapsed {
            max-height: 0;
            padding: 0 10px;
        }
        
        .ndjson-file {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 0px 8px;
            border-radius: 5px;
            margin-bottom: 5px;
            transition: background-color 0.2s;
        }
        
        .file-toggle {
            width: 20px;
            height: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .file-toggle.active {
            background-color: #8B4513;
            color: white;
            border-color: #6B3410;
        }
        
        .file-name {
            flex: 1;
			font-size: 0.65em;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

		.file-name-group {
			display: flex;
			align-items: center;
			gap: 6px;
			white-space: nowrap;
		}

		.file-controls {
			display: flex;
			align-items: center;
			margin-left: auto;
			gap: 5px;
		}
        
        .file-count {
            font-size: 12px;
            color: #888;
            background-color: #f0f0f0;
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        .color-picker {
            width: 24px;
            height: 24px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            padding: 0;
        }
        
		.settings-section {
			background-color: #fff;
			border-radius: 10px;
			padding: 20px;
			box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
			height: 100%;
			display: flex;
			flex-direction: column;
		}
        
        .settings-title {
            color: #8B4513;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        .setting-group {
            flex-grow: 1;
        }
        
		.setting-row {
			display: flex;
			align-items: center;
			gap: 15px;
			margin-bottom: 15px;
		}

		.setting-label {
			min-width: 150px;
			font-weight: 600;
			color: #555;
			flex-shrink: 0;
		}

		#apply-settings {
			margin-top: auto;
		}
        
        /* Styles for map controls */
        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .view-options {
            display: flex;
            gap: 5px;
        }
        
        .view-options button {
            padding: 5px 10px;
            font-size: 12px;
            background: #f0f0f0;
            color: black;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .view-options button.active {
            background: #8B4513;
            color: white;
            border-color: #6B3410;
        }
        
        .slider-container {
            display: none;
            padding: 10px;
            border-radius: 5px;
            margin-top: 5px;
        }

        .slider-container label {
          display: block;
          text-align: center;
          font-weight: 600;
          margin-bottom: 6px;
        }
        
        .slider-container.active {
            display: block;
        }
        
        .slider-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        /* Custom styles for smaller noUiSlider handles */
        .noUi-handle {
            width: 12px !important;
            height: 12px !important;
            right: -6px !important;
            top: -4px !important;
            border: 1px solid #333;
            box-sizing: border-box;
        }

        .noUi-horizontal .noUi-handle {
            width: 16px !important;
            height: 16px !important;
            right: -8px !important;
            top: -5px !important;
        }

        .noUi-handle:before, .noUi-handle:after {
            display: none !important;
        }

        .noUi-connect {
            background-color: transparent !important;
        }

        .noUi-target {
            border: 1px solid #ddd !important;
            box-shadow: none !important;
        }

        .noUi-tooltip {
            font-size: 10px !important;
            padding: 2px 5px !important;
            background: #8B4513 !important;
            color: white !important;
            border: none !important;
            border-radius: 3px !important;
        }

        /* Adjust the slider height */
        .noUi-horizontal {
            height: 8px !important;
        }

        /* Make sure the handle is properly positioned */
        .noUi-horizontal .noUi-handle-lower {
            right: -7px !important;
        }

        .noUi-horizontal .noUi-handle-upper {
            right: -7px !important;
        }
        
        .fullscreen-btn {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            color: black;
            padding: 5px 10px;
            border-radius: 3px;
            border: 1px solid #ddd;
            cursor: pointer;
            font-size: 12px;
        }
        
        .fullscreen-btn:hover {
            background: #f0f0f0;
        }
        
        /* Fullscreen styles */
        .map-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
        }
        
        .map-container.fullscreen .map-controls {
            top: 20px;
            right: 20px;
        }
        
        .map-container.fullscreen .fullscreen-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
        }

        /* Legend container styles */
        .legend-container {
            position: absolute;
            bottom: 50px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none;
            max-width: 200px;
            font-size: 12px;
        }

        .legend-container.active {
            display: block;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            text-align: center;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        .legend-gradient {
            height: 20px;
            width: 100%;
            border-radius: 3px;
            margin-bottom: 8px;
            border: 1px solid #ddd;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #555;
        }

        /* Month legend grid styles */
        .month-legend-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            margin-top: 5px;
        }

        .month-legend-item {
            display: flex;
            align-items: center;
            padding: 2px;
            font-size: 10px;
        }

        .month-color-box {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 4px;
            border: 1px solid rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        .month-label {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 9px;
        }

		.highlighted-point {
			background-color: #FFA500 !important;
			border-color: #FFD700 !important;
			z-index: 10000 !important;
		}

		.chart-highlight {
			background-color: #FFA500 !important;
			border-color: #FFD700 !important;
			border-width: 3px !important;
			z-index: 10 !important;
		}

		#user-point-color, #highlight-color {
			display: flex;
			align-items: center;
			width: 30px;
			min-height: 20px;
			min-width: 20px;
			border: 1px solid #ddd;
			border-radius: 4px;
			cursor: pointer;
			padding: 0;
		}

		#clear-user-points {
			background: none;
			border: 1px solid #ddd;
			border-radius: 4px;
			padding: 5px 10px;
			cursor: pointer;
			font-size: 14px;
		}

		#clear-user-points:hover {
			background-color: #f0f0f0;
		}

		.aspect-circular-container {
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 10px;
			border-radius: 5px;
			margin-top: 5px;
		}

		.aspect-inputs {
			display: flex;
			align-items: center;
			gap: 15px;
			margin-bottom: 15px;
			width: 100%;
			justify-content: center;
		}

		.aspect-input {
			display: flex;
			align-items: center;
			gap: 5px;
		}

		.aspect-input input {
			width: 60px;
			padding: 5px;
			border: 1px solid #ddd;
			border-radius: 3px;
			text-align: center;
		}

		.aspect-circle {
			position: relative;
			width: 200px;
			height: 200px;
			border-radius: 50%;
			background: conic-gradient(
				from 180deg,
				#ff0000 0deg,
				#ffff00 90deg,
				#00ff00 180deg,
				#0000ff 270deg,
				#ff0000 360deg
			);
			border: 2px solid white;
			box-shadow: 0 2px 5px rgba(0,0,0,0.2);
		}

		/* Selected range overlay */
		.aspect-selected-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			border-radius: 50%;
			pointer-events: none;
		}

		.aspect-handle {
			position: absolute;
			width: 16px;
			height: 16px;
			border-radius: 50%;
			background: #cc5d31;
			border: 2px solid white;
			cursor: pointer;
			box-shadow: 0 2px 5px rgba(0,0,0,0.3);
			transform: translate(-50%, -50%);
			z-index: 10;
		}

		.aspect-handle.start {
			background: #8B4513;
		}

		.aspect-handle.end {
			background: #cc5d31;
		}

		.aspect-center {
			position: absolute;
			top: 50%;
			left: 50%;
			width: 60%;
			height: 60%;
			background: white;
			border-radius: 50%;
			transform: translate(-50%, -50%);
			pointer-events: none;
		}

		.aspect-north {
			position: absolute;
			top: 10px;
			left: 50%;
			transform: translateX(-50%);
			font-size: 12px;
			font-weight: bold;
			color: #333;
		}

		.aspect-compass {
			position: absolute;
			font-size: 12px;
			font-weight: bold;
			color: #333;
			pointer-events: none;
			text-shadow: 1px 1px 1px white;
		}

		/* Main compass directions */
		.aspect-compass.north { top: -20px; left: 50%; transform: translateX(-50%); }
		.aspect-compass.east { top: 50%; right: -20px; transform: translateY(-50%); }
		.aspect-compass.south { bottom: -20px; left: 50%; transform: translateX(-50%); }
		.aspect-compass.west { top: 50%; left: -20px; transform: translateY(-50%); }

		/* Intermediate directions */
		.aspect-compass.northeast { top: 10px; right: 10px; }
		.aspect-compass.southeast { bottom: 10px; right: 10px; }
		.aspect-compass.southwest { bottom: 10px; left: 10px; }
		.aspect-compass.northwest { top: 10px; left: 10px; }

		/* Degree markers */
		.aspect-degree {
			position: absolute;
			font-size: 10px;
			color: #666;
			pointer-events: none;
		}

		.aspect-degree.zero { top: 5px; left: 50%; transform: translateX(-50%); }
		.aspect-degree.ninety { top: 50%; right: 5px; transform: translateY(-50%); }
		.aspect-degree.one-eighty { bottom: 5px; left: 50%; transform: translateX(-50%); }
		.aspect-degree.two-seventy { top: 50%; left: 5px; transform: translateY(-50%); }

		/* Dark/Light Mode Styles */
		:root {
			--bg-color: #f5f5f5;
			--text-color: #333;
			--card-bg: #fff;
			--border-color: #ddd;
			--header-color: #8B4513;
			--shadow-color: rgba(0, 0, 0, 0.08);
			--input-bg: #fff;
			--input-border: #ddd;
			--table-header-bg: #8B4513;
			--table-header-color: white;
			--table-row-even: #f9f9f9;
			--table-row-hover: #f0f0f0;
			--link-color: #1a73e8;
			--loading-color: #8B4513;
			--slider-bg: #f0f0f0;
			--slider-border: #ddd;
			--hrib-color: #8B4513;
			--habitat-color: #ac713a;
		}
		
		[data-theme="dark"] {
			--bg-color: #121212;
			--text-color: #e0e0e0;
			--card-bg: #1e1e1e;
			--border-color: #444;
			--header-color: #D9AE86;
			--shadow-color: rgba(0, 0, 0, 0.3);
			--input-bg: #2d2d2d;
			--input-border: #555;
			--table-header-bg: #2c1810;
			--table-header-color: #e0e0e0;
			--table-row-even: #252525;
			--table-row-hover: #333;
			--link-color: #64b5f6;
			--loading-color: #D9AE86;
			--slider-bg: #2d2d2d;
			--slider-border: #555;
			--hrib-color: #ac713a;
			--habitat-color: #D9AE86;
		}
		
		/* Apply CSS variables to elements */
		body {
			background-color: var(--bg-color);
			color: var(--text-color);
		}
		
		.description,
		.graph-container,
		.input-section,
		.ndjson-directory,
		.settings-section,
		.info-panel,
		.folder {
			background-color: var(--card-bg);
			box-shadow: 0 4px 12px var(--shadow-color);
			border-color: var(--border-color);
		}
		
		.description {
			border-left-color: var(--header-color);
		}
		
		h1, h2, h3, .graph-title, .directory-title, .settings-title, .input-title, .info-title {
			color: var(--header-color);
		}

		.site-title {
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.site-title .hrib {
			color: var(--hrib-color);
		}

		.site-title .habitat {
			color: var(--habitat-color);
		}

		.subtitle {
			color: var(--text-color);
			opacity: 0.8;
		}
		
		input[type="text"], input[type="number"], input[type="date"], select {
			background-color: var(--input-bg);
			border-color: var(--input-border);
			color: var(--text-color);
		}
		
		input[type="text"]:focus, input[type="number"]:focus, input[type="date"]:focus, select:focus {
			border-color: var(--header-color);
		}
		
		.link {
			color: var(--link-color);
		}
		
		.loading {
			color: var(--loading-color);
		}
		
		/* Table styles */
		#data-table thead tr {
			background-color: var(--table-header-bg);
			color: var(--table-header-color);
		}
		
		#data-table tbody tr:nth-child(even) {
			background-color: var(--table-row-even);
		}
		
		#data-table tbody tr:hover {
			background-color: var(--table-row-hover);
		}
		
		/* Folder and file styles */
		.folder-header {
			background-color: var(--card-bg);
			border-bottom-color: var(--border-color);
		}
		
		.setting-label,
		.input-field label,
		.axis-selector label,
		.histogram-controls label,
		.input-header label,
		.folder-name {
			color: var(--text-color);
		}

		.sci-name {
			color: #aaa;
			font-style: italic;
			font-size: 0.8em;
		}

		
		.ndjson-file:hover {
			background-color: var(--table-row-hover);
		}
		
		.file-name {
			color: var(--text-color);
		}
		
		.file-count {
			background-color: var(--slider-bg);
			color: var(--text-color);
		}
		
		/* Slider styles */
		.noUi-target {
			background-color: var(--slider-bg) !important;
			border-color: var(--slider-border) !important;
		}
		
		/* Map controls */
		.map-controls {
			background: var(--card-bg);
			color: var(--text-color);
		}
		
		.view-options button {
			background: var(--slider-bg);
			color: var(--text-color);
			border-color: var(--border-color);
		}

		.slider-container label {
			color: var(--text-color);
		}
		
		.fullscreen-btn {
			background: var(--card-bg);
			color: var(--text-color);
			border-color: var(--border-color);
		}
		
		.fullscreen-btn:hover {
			background: var(--slider-bg);
		}
		
		/* Legend container */
		.legend-container {
			background: var(--card-bg);
			color: var(--text-color);
		}
		
		/* Theme toggle button */
		.theme-switch-container {
			position: absolute;
			top: 20px;
			right: 20px;
		}
		
		.theme-toggle-btn {
			display: flex;
			align-items: center;
			gap: 8px;
			background: var(--card-bg);
			color: var(--text-color);
			border: 1px solid var(--border-color);
			padding: 8px 8px;
			border-radius: 20px;
			cursor: pointer;
			font-size: 14px;
			transition: all 0.3s ease;
		}
		
		.theme-toggle-btn:hover {
			background: var(--slider-bg);
			transform: translateY(-2px);
		}
		
		.theme-toggle-btn i {
			font-size: 16px;
		}
		
		.theme-label {
			font-weight: 600;
		}
		
		/* Update existing styles to use variables */
		header {
			border-bottom-color: var(--header-color);
			position: relative;
		}
		
		.info-item {
			border-bottom-color: var(--border-color);
		}
		
		.info-label {
			color: var(--text-color);
		}
		
		.folder {
			border-color: var(--border-color);
		}
		
		.folder-content {
			background-color: var(--card-bg);
		}
		
		.file-toggle {
			border-color: var(--border-color);
		}
		
		.file-toggle.active {
			background-color: var(--header-color);
			border-color: var(--header-color);
		}
		
		.color-picker {
			border-color: var(--border-color);
		}
		
		/* Control buttons for All/None */
		.control-btn {
			border-color: var(--header-color);
			color: var(--header-color);
		}
		
		/* Chart.js adjustments for dark mode */
		[data-theme="dark"] canvas {
			background-color: var(--card-bg) !important;
		}

		[data-theme="dark"] .chartjs-render-monitor {
			background-color: var(--card-bg) !important;
		}

		[data-theme="dark"] .chartjs-grid {
			stroke: rgba(255, 255, 255, 0.1) !important;
		}

		[data-theme="dark"] .chartjs-tick {
			stroke: #e0e0e0 !important;
			color: #e0e0e0 !important;
		}

		[data-theme="dark"] .chartjs-axis-label {
			fill: #e0e0e0 !important;
			color: #e0e0e0 !important;
		}

		[data-theme="dark"] .chartjs-legend {
			color: #e0e0e0 !important;
		}

		/* This forces Chart.js to use CSS colors */
		.chartjs-render-monitor {
			transition: all 0.3s ease;
		}
		
		/* Leaflet map adjustments */
		[data-theme="dark"] .leaflet-container {
			filter: brightness(0.8) contrast(1.2);
		}
		
		/* Aspect circle */
		.aspect-circle {
			background: conic-gradient(
				from 180deg,
				#ff0000 0deg,
				#ffff00 90deg,
				#00ff00 180deg,
				#0000ff 270deg,
				#ff0000 360deg
			);
			border-color: var(--card-bg);
		}
		
		.aspect-compass, .aspect-degree {
			color: var(--text-color);
			text-shadow: 1px 1px 1px var(--card-bg);
		}
		
		/* Clear user points button */
		#clear-user-points {
			background: var(--card-bg);
			color: var(--text-color);
			border-color: var(--border-color);
		}
		
		#clear-user-points:hover {
			background: var(--slider-bg);
		}

		/* Map theme styles */
		.map-container.light {
			filter: none;
		}
		
		.map-container.dark {
			filter: brightness(0.8) contrast(1.1) saturate(0.9);
		}
		
		.map-theme-toggle {
			position: absolute;
			top: 10px;
			left: 50px;
			z-index: 1000;
			background: var(--card-bg);
			color: var(--text-color);
			border: 1px solid var(--border-color);
			padding: 5px 10px;
			border-radius: 3px;
			cursor: pointer;
			font-size: 12px;
			display: flex;
			align-items: center;
			gap: 5px;
		}
		
		.map-theme-toggle:hover {
			background: var(--slider-bg);
		}

		.hriv-svg {
			width: 50px;
			height: 50px;
			background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='100 0 512 512' width='256' height='256'%3E%3C!-- Cap --%3E%3Cdefs%3E%3CradialGradient id='capGradient' cx='50%25' cy='35%25' r='60%25'%3E%3Cstop offset='0%25' stop-color='%238b4513'/%3E%3Cstop offset='100%25' stop-color='%235a2d0c'/%3E%3C/radialGradient%3E%3ClinearGradient id='stemGradient' x1='0' y1='0' x2='0' y2='1'%3E%3Cstop offset='0%25' stop-color='%23f6e6c8'/%3E%3Cstop offset='100%25' stop-color='%23d2b48c'/%3E%3C/linearGradient%3E%3C/defs%3E%3C!-- Cap --%3E%3Cpath d=' M96 220 C110 140, 200 110, 256 110 C312 110, 402 140, 416 220 C420 250, 390 270, 256 270 C122 270, 92 250, 96 220 Z' fill='url(%23capGradient)' /%3E%3C!-- Cap underside --%3E%3Cellipse cx='256' cy='255' rx='150' ry='22' fill='%23e8d6b0' /%3E%3C!-- Stem --%3E%3Cpath d=' M200 270 C190 330, 190 390, 210 430 C230 465, 282 465, 302 430 C322 390, 322 330, 312 270 Z' fill='url(%23stemGradient)' /%3E%3C!-- Stem texture --%3E%3Cg fill='%23c9a877' opacity='0.7'%3E%3Cellipse cx='240' cy='310' rx='4' ry='8'/%3E%3Cellipse cx='270' cy='330' rx='5' ry='10'/%3E%3Cellipse cx='255' cy='360' rx='4' ry='9'/%3E%3Cellipse cx='235' cy='385' rx='3' ry='7'/%3E%3Cellipse cx='275' cy='395' rx='4' ry='8'/%3E%3C/g%3E%3C/svg%3E%0A");
			background-size: 50px 50px;
			background-position: center center;
			background-repeat: no-repeat;
		}
    </style>
</head>
<body>
	<header>
		<h1 class="site-title">

			<span class="hrib">Hrib</span><span class="habitat">Habita</span>
			<div class="hriv-svg"></div>
		</h1>
		<p class="subtitle">Visualizing the relationship between elevation, soil temperature, soil moisture, slope aspect, and seasonal patterns</p>
		<div class="theme-switch-container">
			<button id="theme-toggle" class="theme-toggle-btn" title="Toggle dark/light mode">
				<i class="fas fa-moon"></i>
				<span class="theme-label">Dark Mode</span>
			</button>
		</div>
	</header>
    
    <div class="description">
        <p>This interactive dashboard explores environmental factors associated with mushroom observations using only open (non-obscured) observation data. The map and plots below show relationships between elevation, soil temperature, soil moisture, slope aspect, and time of year. Click on any point to view detailed information about that observation.</p>
    </div>
    
	<div class="main-container">    
		<!-- Main content area -->
		<div>
			<!-- NDJSON Data Files container -->
			<div class="ndjson-directory">
				<div class="directory-header">
					<div class="directory-title">Data Files</div>
					<div class="directory-controls">
						<button class="control-btn" id="select-all-btn">All</button>
						<button class="control-btn" id="select-none-btn">None</button>
					</div>
				</div>
				<div class="directory-content" id="directory-content">
					<!-- Directory content will be populated by JavaScript -->
					<div class="loading" id="directory-loading">Loading NDJSON directory...</div>
					<div id="ndjson-folder-structure"></div>
				</div>
			</div>
			<!-- Data Settings container -->
			<div class="settings-section">
				<h3 class="settings-title">Data Settings</h3>
				
				<div class="setting-group">
					<div class="setting-row">
						<div class="setting-label">Average Days:</div>
						<select id="average-days">
							<option value="1">1 day</option>
							<option value="3">3 days</option>
							<option value="7" selected>7 days</option>
							<option value="10">10 days</option>
							<option value="14">14 days</option>
						</select>
					</div>
					
					<div class="setting-row">
						<div class="setting-label">Soil Temp Depth:</div>
						<select id="temp-depth">
							<option value="0_to_7cm">0-7 cm</option>
							<option value="7_to_28cm" selected>7-28 cm</option>
							<option value="28_to_100cm">28-100 cm</option>
							<option value="0_to_100cm">0-100 cm</option>
						</select>
					</div>
					
					<div class="setting-row">
						<div class="setting-label">Soil Moisture Depth:</div>
						<select id="moisture-depth">
							<option value="0_to_7cm">0-7 cm</option>
							<option value="7_to_28cm" selected>7-28 cm</option>
							<option value="28_to_100cm">28-100 cm</option>
							<option value="0_to_100cm">0-100 cm</option>
						</select>
					</div>
				</div>
				
				<button id="apply-settings" style="width: 100%;">Apply Settings</button>
			</div>
			</div>
			
			<div class="input-section">
				<div class="input-header">
					<h2 class="input-title">Location Data</h2>
					<div style="display: flex; gap: 10px;">
						<label style="display: flex; align-items: center; gap: 5px; white-space: nowrap; max-height: 30px; font-size: 14px;">Added Point:</label>
						<input type="color" id="user-point-color" value="#FF6B6B" title="User point color">
						<input type="number" id="user-point-size" value="5" min="1" max="20" title="User point size" style="max-width: 80px; max-height: 30px; align-items: center;">
						<label style="display: flex; align-items: center; gap: 5px; white-space: nowrap; max-height: 50px; font-size: 14px;">Selected Point:</label>
						<input type="color" id="highlight-color" value="#FFA500" title="Highlight color">
						<input type="number" id="highlight-point-size" value="5" min="1" max="20" title="Highlight point size" style="max-width: 80px; max-height: 30px; align-items: center;">
						<label style="display: flex; align-items: center; gap: 5px; font-size: 12px; margin-left: 10px; margin-right: 10px; white-space: nowrap;">
							<input type="checkbox" id="disable-scroll"> Disable Scroll
						</label>
						<button id="clear-user-points" title="Clear user points" style="max-height: 30px; align-items: center;">üóëÔ∏è</button>
					</div>
				</div>
                <p style="font-size: 18px;">Enter coordinates manually or click on the map to select a location. The system will retrieve the soil and elevation data from the Open-Meteo Weather API.</p>
                
                <div class="input-group">
                    <div class="input-field" style="flex: 1 1 200px;">
                        <label for="latitude">Latitude</label>
                        <input type="number" id="latitude" step="any" placeholder="e.g., 46.744487" value="46.744487" style="width: 100%;">
                    </div>
                    
                    <div class="input-field" style="flex: 1 1 200px;">
                        <label for="longitude">Longitude</label>
                        <input type="number" id="longitude" step="any" placeholder="e.g., -121.812952" value="-121.812952" style="width: 100%;">
                    </div>
                    
                    <div class="input-field" style="flex: 1 1 200px;">
                        <label for="date">Observation Date</label>
                        <input type="date" id="date" style="width: 100%;">
                    </div>
                    
                    <div class="input-field" style="flex: 1 1 200px;">
                        <label>&nbsp;</label>
                        <button id="fetch-data" style="width: 100%;">Get Soil Data & Elevation</button>
                    </div>
                </div>
                
                <div class="map-container" id="map"></div>
                
                <div class="loading" id="loading">Fetching data from Open-Meteo API...</div>
            </div>
            
			<div class="content-container">
				<div class="graph-container">
					<div class="chart-header">
						<h3 class="graph-title">Data Visualization</h3>
						<div class="chart-controls">
							<div class="axis-selectors">
								<div class="axis-selector">
									<label for="y-axis">Y-Axis:</label>
									<select id="y-axis">
										<option value="elevationFt">Elevation (ft)</option>
										<option value="soilTemp">Soil Temperature (¬∞F)</option>
										<option value="soilMoisture">Soil Moisture</option>
										<option value="slopeDeg">Slope (degrees)</option>
										<option value="slopeAspectDeg">Aspect (degrees)</option>
										<option value="monthFraction">Date</option>
									</select>
								</div>
								<div class="axis-selector">
									<label for="x-axis">X-Axis:</label>
									<select id="x-axis">
										<option value="elevationFt">Elevation (ft)</option>
										<option value="soilTemp">Soil Temperature (¬∞F)</option>
										<option value="soilMoisture">Soil Moisture</option>
										<option value="slopeDeg">Slope (degrees)</option>
										<option value="slopeAspectDeg">Aspect (degrees)</option>
										<option value="monthFraction">Date</option>
									</select>
								</div>
							</div>
						</div>
					</div>
					<div class="chart-wrapper">
						<canvas id="mainChart"></canvas>
					</div>
				</div>
				
				<div class="graph-container">
					<div class="chart-header">
						<h3 class="graph-title">Distribution Histogram</h3>
						<div class="histogram-controls">
							<select id="histogram-dimension">
								<option value="elevationFt">Elevation (ft)</option>
								<option value="soilTemp">Soil Temperature (¬∞F)</option>
								<option value="soilMoisture">Soil Moisture</option>
								<option value="slopeDeg">Slope (degrees)</option>
								<option value="slopeAspectDeg">Aspect (degrees)</option>
								<option value="month">Month</option>
								<option value="yearMonth">Year-Month</option>
							</select>
							<label for="bin-count" style="font-size: 16px; margin-left: 5px;">Bins:</label>
							<input type="number" id="bin-count" min="1" max="100" value="30" style="width: 100px;">
							<label for="bin-offset" style="font-size: 16px; margin-left: 5px;">Offset:</label>
							<input type="number" id="bin-offset" min="0" max="100" value="0" style="width: 100px;">
						</div>
					</div>
					<div class="chart-wrapper">
						<canvas id="histogramChart"></canvas>
					</div>
				</div>
			</div>
            
            <div class="info-panel" id="info-panel">
                <h3 class="info-title">Observation Details</h3>
				<div class="soil-temp-chart-container" style="margin-top: 20px; display: none;" id="soil-temp-chart-container">
					<h4 style="color: #8B4513; margin-bottom: 15px;">Soil Temperature & Moisture Trend</h4>
					<div class="chart-wrapper" style="height: 200px;">
						<canvas id="soil-temp-chart"></canvas>
					</div>
				</div>
                <div class="info-content" id="info-content">
                    <!-- Details will be populated here when a point is clicked -->
                </div>
            </div>
			<div class="graph-container" style="grid-column: 1 / -1; width: 100%; margin-top: 25px;">
				<h3 class="graph-title">Data Table</h3>
				<div id="data-table-container" style="overflow-x: auto;">
					<table id="data-table" style="width: 100%; border-collapse: collapse;">
						<thead>
							<tr style="background-color: #8B4513; color: white; position: sticky; top: 0;">
								<th style="padding: 10px; text-align: center;">Dataset</th>
								<th style="padding: 10px; text-align: center;">Date</th>
								<th style="padding: 10px; text-align: center;">Elevation (ft)</th>
								<th style="padding: 10px; text-align: center;">Soil Temp (¬∞F)</th>
								<th style="padding: 10px; text-align: center;">Soil Moisture</th>
								<th style="padding: 10px; text-align: center;">Slope (deg)</th>
								<th style="padding: 10px; text-align: center;">Aspect (deg)</th>
							</tr>
						</thead>
						<tbody id="table-body">
							<!-- Data will be populated here -->
						</tbody>
					</table>
				</div>
			</div>
        </div>
    </div>
    
    <footer>
		<p>Github: <a href="https://github.com/BobTheFish1238/hrib-elev" target="_blank" class="link">hrib-elev</a> </p>
        <p>(Observations data is updated periodically)</p>
        <p>Data Sources: iNaturalist observations & Open-Meteo Weather API</p>
        <p>Note: The Open-Meteo API provides soil temperature data with a spatial resolution of 9 km for recent years (IFS model) or 0.25¬∞ (~25 km) for historical data (ERA5 model).</p>
    </footer>

    <script>
		L.TileLayer.StyleFilter = L.TileLayer.extend({
			initialize: function(url, options) {
				L.TileLayer.prototype.initialize.call(this, url, options);
				this._filter = options.filter || '';
			},
			
			createTile: function(coords, done) {
				const tile = L.TileLayer.prototype.createTile.call(this, coords, done);
				
				if (this._filter) {
					const img = tile.tagName === 'IMG' ? tile : tile.querySelector('img');
					if (img) {
						img.style.filter = this._filter;
						img.style.webkitFilter = this._filter;
					}
				}
				
				return tile;
			}
		});

		L.tileLayer.styleFilter = function(url, options) {
			return new L.TileLayer.StyleFilter(url, options);
		};

		L.TileLayer.USGS = L.TileLayer.extend({
			initialize: function (url, options) {
				L.TileLayer.prototype.initialize.call(this, url, options);
				this._url = url;
			},
			
			getTileUrl: function (coords) {
				var data = {
					x: coords.x,
					y: coords.y,
					z: this._getZoomForUrl()
				};
				
				let mMax = 20037508.3428;
				let mTile = 2 * mMax / (Math.pow(2, data.z));
				let bb = [
					data.x * mTile - mMax,
					-(data.y + 1) * mTile + mMax,
					(data.x + 1) * mTile - mMax,
					-data.y * mTile + mMax,
				];
				
				data['p'] = `f=image&bboxSR=102100&imageSR=102100&size=${this._tileSize.x},${this._tileSize.y}&bbox=${bb[0]},${bb[1]},${bb[2]},${bb[3]}`;
				
				if (this.options.renderingRule) { 
					data['p'] += `&renderingRule=%7B"rasterFunction"%3A"${this.options.renderingRule}"%7D`; 
				}
				
				return this._url + data.p;
			},
			
			styleFilter: function () {
				var filters = this.options.filter || '';
				return filters;
			},
			
			_initContainer: function () {
				var tile = L.TileLayer.prototype._initContainer.call(this);
				this._container.style.filter = this.styleFilter();
			},
		});

		L.tileLayer.usgs = function (url, options) {
			return new L.TileLayer.USGS(url, options);
		};

		var s_usgs_3dep_urlbase = 'https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/exportImage?';
		var s_usgs_3dep_attribution = '<a href="https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer">USGS 3D Elevation Program</a>';

        // Global variables
        let originalData = []; // Store all loaded NDJSON data
        let activeDatasets = {}; // Track active NDJSON files with their colors
        let userData = []; // User-added data points
        let allData = []; // Combined data from all sources
        let chartData = []; // Processed data for charts
        
		// Chart instances
		let mainChart, histogramChart;
        
        // Initialize map
		let map;
		let marker;
		let mapPoints = [];
		let currentView = 'default';
		let currentBaseLayer = 'osm_std'; // Default layer
		let darkMode = false; // Track dark mode for map layers
		let elevationRange = [0, 12000];
		let tempRange = [0, 100];
		let moistureRange = [0, 1];
		let slopeRange = [0, 90];
		let aspectRange = [0, 360];
		let monthRange = [1, 12];
		let highlightedPoint = null;
		let highlightedChartElements = [];
        
        // Settings
        let averageDays = 7;
        let tempDepth = '7_to_28cm';
        let moistureDepth = '7_to_28cm';

		let userPointColor = '#FF6B6B';
		let highlightColor = '#FFA500';
		let enableScroll = true;
		let userPointSize = 5;
		let highlightPointSize = 5;
		let pointSize = 2;

		// Available tile layers
		const tileLayers = {
			// Watercolor layers
			watercolor: {
				name: 'Stamen Watercolor',
				layer: L.tileLayer('https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/{z}/{x}/{y}.jpg', {
					minZoom: 0,
					maxZoom: 20,
					attribution: 'Map <a href="https://watercolormaps.collection.cooperhewitt.org">tiles</a> by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'
				})
			},
			watercolor_muted: {
				name: 'Watercolor Muted',
				layer: (function() {
					const layer = L.tileLayer('https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/{z}/{x}/{y}.jpg', {
						minZoom: 0,
						maxZoom: 20,
						attribution: 'Map <a href="https://watercolormaps.collection.cooperhewitt.org">tiles</a> by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'
					});
					// Apply filter via event
					layer.on('tileload', function(e) {
						e.tile.style.filter = 'grayscale(85%)';
						e.tile.style.webkitFilter = 'grayscale(85%)';
					});
					return layer;
				})()
			},
			watercolor_gray: {
				name: 'Watercolor Gray',
				layer: (function() {
					const layer = L.tileLayer('https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/{z}/{x}/{y}.jpg', {
						minZoom: 0,
						maxZoom: 20,
						attribution: 'Map <a href="https://watercolormaps.collection.cooperhewitt.org">tiles</a> by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'
					});
					layer.on('tileload', function(e) {
						e.tile.style.filter = 'grayscale(100%)';
						e.tile.style.webkitFilter = 'grayscale(100%)';
					});
					return layer;
				})()
			},
			watercolor_darkgray: {
				name: 'Watercolor Dark Gray',
				layer: (function() {
					const layer = L.tileLayer('https://watercolormaps.collection.cooperhewitt.org/tile/watercolor/{z}/{x}/{y}.jpg', {
						minZoom: 0,
						maxZoom: 20,
						attribution: 'Map <a href="https://watercolormaps.collection.cooperhewitt.org">tiles</a> by <a href="http://stamen.com">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>. Data by <a href="https://openstreetmap.org">OpenStreetMap</a>, under <a href="https://creativecommons.org/licenses/by-sa/3.0">CC BY SA</a>.'
					});
					layer.on('tileload', function(e) {
						e.tile.style.filter = 'grayscale(100%) brightness(50%)';
						e.tile.style.webkitFilter = 'grayscale(100%) brightness(50%)';
					});
					return layer;
				})()
			},
			
			// OpenStreetMap variants
			osm_std: {
				name: 'OpenStreetMap Standard',
				layer: L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
					minZoom: 0,
					maxNativeZoom: 19,
					maxZoom: 20,
					attribution: '&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles from <a href="https://osm.org/">OpenStreetMap</a>'
				})
			},
			osm_de: {
				name: 'OpenStreetMap DE',
				layer: L.tileLayer('https://tile.openstreetmap.de/{z}/{x}/{y}.png', {
					minZoom: 0,
					maxZoom: 20,
					attribution: '&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles <a href="https://openstreetmap.de/">OpenStreetMap Deutschland</a>'
				})
			},
			osm_fr: {
				name: 'OpenStreetMap FR',
				layer: L.tileLayer('https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png', {
					minZoom: 0,
					maxZoom: 20,
					attribution: 'donn&eacute;es &copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - rendu <a href="https://openstreetmap.fr">OSM France</a>'
				})
			},
			osm_hot: {
				name: 'OpenStreetMap HOT',
				layer: L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
					minZoom: 0,
					maxNativeZoom: 19,
					maxZoom: 20,
					attribution: 'donn&eacute;es &copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - Tiles courtesy of <a href="https://hot.openstreetmap.org/">Humanitarian OpenStreetMap Team</a>'
				})
			},
			
			// OpenTopoMap variants
			otm: {
				name: 'OpenTopoMap',
				layer: L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
					minZoom: 0,
					maxNativeZoom: 17,
					maxZoom: 20,
					attribution: 'Kartendaten: &copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap</a>-Mitwirkende, SRTM | Kartendarstellung: &copy; <a href="http://opentopomap.org/">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
				})
			},
			otm_muted: {
				name: 'OpenTopoMap Muted',
				layer: (function() {
					const layer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
						minZoom: 0,
						maxNativeZoom: 17,
						maxZoom: 20,
						attribution: 'Kartendaten: &copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap</a>-Mitwirkende, SRTM | Kartendarstellung: &copy; <a href="http://opentopomap.org/">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
					});
					layer.on('tileload', function(e) {
						e.tile.style.filter = 'grayscale(60%)';
						e.tile.style.webkitFilter = 'grayscale(60%)';
					});
					return layer;
				})()
			},
			
			// OSM Modified variants - using our custom styleFilter implementation
			osm_lightgray: {
				name: 'OSM Light Gray',
				layer: (function() {
					const layer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
						minZoom: 0,
						maxZoom: 20,
						attribution: '&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles from <a href="https://osm.org/">OpenStreetMap</a>'
					});
					layer.on('tileload', function(e) {
						e.tile.style.filter = 'grayscale(100%)';
						e.tile.style.webkitFilter = 'grayscale(100%)';
					});
					return layer;
				})()
			},
			osm_medgray: {
				name: 'OSM Medium Gray',
				layer: (function() {
					const layer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
						minZoom: 0,
						maxZoom: 20,
						attribution: '&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles from <a href="https://osm.org/">OpenStreetMap</a>'
					});
					layer.on('tileload', function(e) {
						e.tile.style.filter = 'grayscale(100%) brightness(50%) contrast(150%)';
						e.tile.style.webkitFilter = 'grayscale(100%) brightness(50%) contrast(150%)';
					});
					return layer;
				})()
			},
			osm_medgray2: {
				name: 'OSM Medium Gray 2',
				layer: (function() {
					const layer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
						minZoom: 0,
						maxZoom: 20,
						attribution: '&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles from <a href="https://osm.org/">OpenStreetMap</a>'
					});
					layer.on('tileload', function(e) {
						e.tile.style.filter = 'grayscale(100%) brightness(50%) contrast(150%) invert(100%) contrast(125%)';
						e.tile.style.webkitFilter = 'grayscale(100%) brightness(50%) contrast(150%) invert(100%) contrast(125%)';
					});
					return layer;
				})()
			},
			osm_darkgray: {
				name: 'OSM Dark Gray',
				layer: (function() {
					const layer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
						minZoom: 0,
						maxZoom: 20,
						attribution: '&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles from <a href="https://osm.org/">OpenStreetMap</a>'
					});
					layer.on('tileload', function(e) {
						e.tile.style.filter = 'grayscale(100%) invert(100%)';
						e.tile.style.webkitFilter = 'grayscale(100%) invert(100%)';
					});
					return layer;
				})()
			},
			osm_darkest: {
				name: 'OSM Darkest',
				layer: (function() {
					const layer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
						minZoom: 0,
						maxZoom: 20,
						attribution: '&copy; <a href="https://osm.org/copyright">OpenStreetMap</a>/ODbL - tiles from <a href="https://osm.org/">OpenStreetMap</a>'
					});
					layer.on('tileload', function(e) {
						e.tile.style.filter = 'grayscale(100%) invert(100%) brightness(80%) contrast(125%)';
						e.tile.style.webkitFilter = 'grayscale(100%) invert(100%) brightness(80%) contrast(125%)';
					});
					return layer;
				})()
			},
			
			// EOX Layers
			eox_osm: {
				name: 'EOX OSM',
				layer: L.tileLayer('https://tiles.maps.eox.at/wmts/1.0.0/osm_3857/default/g/{z}/{y}/{x}.jpg', {
					minZoom: 0,
					maxNativeZoom: 18,
					maxZoom: 20,
					attribution: '<a href="https://maps.eox.at">OpenStreetMap</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Rendering &copy; <a href="https://eox.at">EOX</a> and <a href="https://github.com/mapserver/basemaps">MapServer</a> }'
				})
			},
			eox_blackmarble: {
				name: 'EOX Black Marble',
				layer: L.tileLayer('https://tiles.maps.eox.at/wmts/1.0.0/blackmarble_3857/default/g/{z}/{y}/{x}.jpg', {
					minZoom: 0,
					maxNativeZoom: 18,
					maxZoom: 20,
					attribution: '<a href="https://maps.eox.at">Black Marble</a> { &copy; <a href="http://nasa.gov">NASA</a> }'
				})
			},
			eox_bluemarble: {
				name: 'EOX Blue Marble',
				layer: L.tileLayer('https://tiles.maps.eox.at/wmts/1.0.0/bluemarble_3857/default/g/{z}/{y}/{x}.jpg', {
					minZoom: 0,
					maxNativeZoom: 18,
					maxZoom: 20,
					attribution: '<a href="https://maps.eox.at">Blue Marble</a> { &copy; <a href="http://nasa.gov">NASA</a> }'
				})
			},
			eox_terrain: {
				name: 'EOX Terrain',
				layer: L.tileLayer('https://tiles.maps.eox.at/wmts/1.0.0/terrain_3857/default/g/{z}/{y}/{x}.jpg', {
					minZoom: 0,
					maxNativeZoom: 18,
					maxZoom: 20,
					attribution: '<a href="https://maps.eox.at">Terrain</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors and <a href="https://maps.eox.at/#data">others</a>, Rendering &copy; <a href="https://eox.at">EOX</a> }'
				})
			},
			eox_terrain_light: {
				name: 'EOX Terrain Light',
				layer: L.tileLayer('https://tiles.maps.eox.at/wmts/1.0.0/terrain-light_3857/default/g/{z}/{y}/{x}.jpg', {
					minZoom: 0,
					maxNativeZoom: 18,
					maxZoom: 20,
					attribution: '<a href="https://maps.eox.at">Terrain Light</a> { Data &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors and <a href="https://maps.eox.at/#data">others</a>, Rendering &copy; <a href="https://eox.at">EOX</a> }'
				})
			},
			
			// Sentinel Layers (using 2024 as default)
			sentinel_2024: {
				name: 'Sentinel-2 2024',
				layer: L.tileLayer('https://tiles.maps.eox.at/wmts/1.0.0/s2cloudless-2024_3857/default/g/{z}/{y}/{x}.jpg', {
					minZoom: 0,
					maxZoom: 20,
					attribution: '<a xmlns:dct="http://purl.org/dc/terms/" href="https://s2maps.eu" property="dct:title">Sentinel-2 cloudless - https://s2maps.eu</a> by <a xmlns:cc="http://creativecommons.org/ns#" href="https://eox.at" property="cc:attributionName" rel="cc:attributionURL">EOX IT Services GmbH</a> (Contains modified Copernicus Sentinel data 2024) released under <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>. For commercial usage please see <a href="https://cloudless.eox.at">https://cloudless.eox.at</a>'
				})
			},
			
			// USGS Layers
			usgs_topo: {
				name: 'USGS Topo',
				layer: L.tileLayer('https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}', {
					minZoom: 0,
					maxNativeZoom: 16,
					attribution: '<a href="https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer">USGS The National Map</a>'
				})
			},
			usgs_img: {
				name: 'USGS Imagery',
				layer: L.tileLayer('https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}', {
					minZoom: 0,
					maxNativeZoom: 16,
					maxZoom: 20,
					attribution: '<a href="https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer">USGS The National Map</a>: Orthoimagery'
				})
			},
			usgs_imgtopo: {
				name: 'USGS Imagery+Topo',
				layer: L.tileLayer('https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer/tile/{z}/{y}/{x}', {
					minZoom: 0,
					maxNativeZoom: 16,
					maxZoom: 20,
					attribution: '<a href="https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryTopo/MapServer">USGS The National Map</a>: Orthoimagery and US Topo'
				})
			},
			usgs_hillshade: {
				name: 'USGS Hillshade',
				layer: L.tileLayer.usgs(s_usgs_3dep_urlbase, {
					minZoom: 0, 
					maxZoom: 20, 
					attribution: s_usgs_3dep_attribution, 
					renderingRule: 'Hillshade Gray'
				})
			},
			usgs_aspect: {
				name: 'USGS Aspect Map',
				layer: L.tileLayer.usgs(s_usgs_3dep_urlbase, {
					minZoom: 0, 
					maxZoom: 20, 
					attribution: s_usgs_3dep_attribution, 
					renderingRule: 'Aspect Map'
				})
			},
			usgs_slope: {
				name: 'USGS Slope Map',
				layer: L.tileLayer.usgs(s_usgs_3dep_urlbase, {
					minZoom: 0, 
					maxZoom: 20, 
					attribution: s_usgs_3dep_attribution, 
					renderingRule: 'Slope Map'
				})
			}
		};


		// Define layer groups for organization
		const layerGroups = {
			watercolor: ['watercolor', 'watercolor_muted', 'watercolor_gray', 'watercolor_darkgray'],
			osm: ['osm_std', 'osm_de', 'osm_fr', 'osm_hot', 'osm_lightgray', 'osm_medgray', 'osm_medgray2', 'osm_darkgray', 'osm_darkest'],
			topo: ['otm', 'otm_muted', 'eox_terrain', 'eox_terrain_light', 'usgs_topo', 'usgs_hillshade', 'usgs_aspect', 'usgs_slope'],
			satellite: ['eox_blackmarble', 'eox_bluemarble', 'sentinel_2024', 'usgs_img', 'usgs_imgtopo'],
			dark: ['osm_darkgray', 'osm_darkest', 'watercolor_darkgray', 'eox_blackmarble', 'osm_medgray', 'osm_medgray2'],
			light: ['osm_std', 'osm_lightgray', 'watercolor', 'eox_terrain_light']
		};

		function clearUserPoints() {
			userData = [];
			
			// Update all charts
			if (mainChart && histogramChart) {
				updateCharts();
			}
			
			// Remove user points from map
			mapPoints.forEach((marker, index) => {
				if (marker._datasetId === 'user_data') {
					map.removeLayer(marker);
					// Don't splice while iterating - mark for removal
				}
			});
			
			// Filter out user markers
			mapPoints = mapPoints.filter(marker => marker._datasetId !== 'user_data');
			
			// Update data table
			populateDataTable();
			
			// Clear any highlights and info panel
			removeHighlights();
			document.getElementById('info-panel').classList.remove('active');
		}

		// Debouncer function
		function debounce(func, wait) {
			let timeout;
			return function executedFunction(...args) {
				const later = () => {
					clearTimeout(timeout);
					func(...args);
				};
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
			};
		}

		// Function to make number inputs scrollable with mouse wheel
		function makeInputScrollable(inputElement, min, max, step = 1) {
			inputElement.addEventListener('wheel', function(e) {
				e.preventDefault();
				
				let currentValue = parseInt(this.value) || min;
				let newValue;
				
				if (e.deltaY < 0) {
					// Scrolling up - increase value
					newValue = Math.min(currentValue + step, max);
				} else {
					// Scrolling down - decrease value
					newValue = Math.max(currentValue - step, min);
				}
				
				if (newValue !== currentValue) {
					this.value = newValue;
					this.dispatchEvent(new Event('input', { bubbles: true }));
				}
			});
			
			inputElement.addEventListener('keydown', function(e) {
				if (e.key === 'ArrowUp') {
					e.preventDefault();
					let currentValue = parseInt(this.value) || min;
					let newValue = Math.min(currentValue + step, max);
					this.value = newValue;
					this.dispatchEvent(new Event('input', { bubbles: true }));
				} else if (e.key === 'ArrowDown') {
					e.preventDefault();
					let currentValue = parseInt(this.value) || min;
					let newValue = Math.max(currentValue - step, min);
					this.value = newValue;
					this.dispatchEvent(new Event('input', { bubbles: true }));
				}
			});
		}

		// Function to highlight a point across all visualizations
		function highlightPoint(point) {
			// Remove previous highlights
			removeHighlights();
			
			// Store the highlighted point
			highlightedPoint = point;
			
			// Highlight on map
			mapPoints.forEach(marker => {
				// Add null check
				if (!marker || !marker.setStyle) return;
				
				const latlng = marker.getLatLng();
				// Add null check for latlng
				if (!latlng) return;
				
				if (Math.abs(latlng.lat - point.latitude) < 0.0001 && 
					Math.abs(latlng.lng - point.longitude) < 0.0001) {
					
					// Check if this is a user point
					const isUserPoint = point.datasetId === 'user_data';
					
					if (isUserPoint) {
						// User points
						marker.setStyle({
							fillColor: userPointColor,
							color: userPointColor,
							fillOpacity: 0.9,
							weight: 3,
							radius: userPointSize
						});
					} else {
						// Regular points
						marker.setStyle({
							fillColor: highlightColor,
							color: highlightColor,
							fillOpacity: 0.9,
							weight: 3,
							radius: highlightPointSize
						});
					}
					
					marker.bringToFront();
				}
			});
			
			// Highlight on charts
			if (mainChart && mainChart.data && mainChart.data.datasets) {
				// Create a separate highlighted dataset for this point
				const observationId = point.observationUrl ? 
					point.observationUrl.split('/').pop() : 
					'User Point';
				const highlightDataset = {
					label: `Obs: ${observationId}`,
					data: [{
						x: point.x || point[getXProperty(mainChart)],
						y: point.y || point[getYProperty(mainChart)],
						...point
					}],
					backgroundColor: highlightColor,
					borderColor: highlightColor,
					borderWidth: 1,
					pointRadius: highlightPointSize,
					pointHoverRadius: highlightPointSize,
					order: -1,
					datasetId: 'highlighted_point'
				};
				
				// Check if highlight dataset already exists
				const existingIndex = mainChart.data.datasets.findIndex(ds => ds.datasetId === 'highlighted_point');
				if (existingIndex > -1) {
					mainChart.data.datasets[existingIndex] = highlightDataset;
				} else {
					mainChart.data.datasets.push(highlightDataset);
				}
				
				highlightedChartElements.push({
					chart: mainChart,
					datasetIndex: mainChart.data.datasets.length - 1
				});
				
				mainChart.update('none');
			}
		}

		// Function to remove all highlights
		function removeHighlights() {
			// Remove chart highlights
			highlightedChartElements.forEach(item => {
				if (item.chart && item.chart.data && item.chart.data.datasets) {
					// Remove the highlighted dataset
					const highlightIndex = item.chart.data.datasets.findIndex(ds => ds.datasetId === 'highlighted_point');
					if (highlightIndex > -1) {
						item.chart.data.datasets.splice(highlightIndex, 1);
						item.chart.update('none');
					}
				}
			});
			
			highlightedChartElements = [];
			highlightedPoint = null;
			
			// Simply update the map points to redraw them with original colors
			updateMapPoints();
		}

		// Function to save original marker styles
		function saveOriginalMarkerStyles() {
			mapPoints.forEach(marker => {
				if (!marker.options._originalFillColor) {
					marker.options._originalFillColor = marker.options.fillColor;
					marker.options._originalColor = marker.options.color;
				}
			});
		}

		// Helper function to get X property based on chart
		function getXProperty(chart) {
			if (chart === mainChart) {
				const xProp = document.getElementById('x-axis') ? document.getElementById('x-axis').value : 'soilTemp';
				return xProp;
			}
			return 'soilTemp';
		}

		// Helper function to get Y property based on chart
		function getYProperty(chart) {
			if (chart === mainChart) {
				const yProp = document.getElementById('y-axis') ? document.getElementById('y-axis').value : 'elevationFt';
				return yProp;
			}
			return 'elevationFt';
		}
        
        // Color scales
		const elevationColorScale = d3.scaleLinear()
			.domain([0, 2000, 4000, 6000, 8000, 10000, 12000])
			.range([
				'#6A0DAD', // Purple at 0 ft
				'#0000FF', // Blue at 2000 ft
				'#00FF00', // Green at 4000 ft
				'#FFFF00', // Yellow at 6000 ft
				'#FFA500', // Orange at 8000 ft
				'#FF4500', // Red-Orange at 10000 ft
				'#FF0000'  // Red at 12000 ft
			]);

		const tempColorScale = d3.scaleLinear()
			.domain([45, 65])
			.range(['#0000FF', '#FF0000'])
			.interpolate(d3.interpolateHcl);

		const moistureColorScale = d3.scaleLinear()
			.domain([0.2, 0.4])
			.range(['#FFD700', '#00008B']); // Gold to Dark Blue

		// Slope degree color scale
		const slopeColorScale = d3.scaleLinear()
			.domain([0, 90])
			.range(['#00FF00', '#FF0000']) // Green to Red
			.interpolate(d3.interpolateHcl);

		// Slope aspect color scale (circular color scale for 0-360 degrees)
		const aspectColorScale = d3.scaleLinear()
			.domain([0, 90, 180, 270, 360])
			.range(['#FF0000', '#FFFF00', '#00FF00', '#0000FF', '#FF0000']); // Red->Yellow->Green->Blue->Red

        // Month colors
        const monthColors = [
            '#FF6B6B', // Jan - Deep Red
            '#FF8E53', // Feb - Orange-Red
            '#FFB347', // Mar - Orange
            '#FFD166', // Apr - Yellow-Orange
            '#A8E6CF', // May - Light Green
            '#7BC8A4', // Jun - Green
            '#4ECDC4', // Jul - Teal
            '#45B7D1', // Aug - Light Blue
            '#6C5CE7', // Sep - Purple
            '#A29BFE', // Oct - Lavender
            '#DDA0DD', // Nov - Plum
            '#FFB6C1'  // Dec - Pink
        ];
        
        // NDJSON directory structure
		const ndjsonStructure = {
			"Boletus": {
				"King Bolete (Boletus edulis)": [
					{name: "Washington_Boletus_edulis.ndjson", modified: "2026-01-02"},
					{name: "Oregon_Boletus_edulis.ndjson",  modified: "2026-01-02"},
					{name: "California_Boletus_edulis.ndjson", modified: "2026-01-03"}
				],
				"Spring King Bolete (Boletus rex-veris)": [
					{name: "Washington_Boletus_rex-veris.ndjson", modified: "2026-01-02"},
					{name: "Oregon_Boletus_rex-veris.ndjson", modified: "2026-01-02"},
					{name: "California_Boletus_rex-veris.ndjson", modified: "2026-01-03"}
				],
				"Fib King (Boletus fibrillosus)": [
					{name: "Washington_Boletus_fibrillosus.ndjson", modified: "2026-01-07"},
					{name: "Oregon_Boletus_fibrillosus.ndjson", modified: "2026-01-07"},
					{name: "California_Boletus_fibrillosus.ndjson", modified: "2026-01-07"}
				],
				"Barrow's Bolete (Boletus barrowsii)": [
					{name: "Washington_Boletus_barrowsii.ndjson", modified: "2026-01-07"},
					{name: "Oregon_Boletus_barrowsii.ndjson", modified: "2026-01-07"},
					{name: "California_Boletus_barrowsii.ndjson", modified: "2026-01-07"}
				]
			},
			"Black Morels (Morchella sect. Distantes)": {
				"Black Morel (Morchella angusticeps)": [
					{name: "Washington_Morchella_angusticeps.ndjson", modified: "2026-01-07"}
				],
				"Landscaping Black Morel (Morchella importuna)": [
					{name: "Washington_Morchella_importuna.ndjson", modified: "2026-01-07"},
					{name: "Oregon_Morchella_importuna.ndjson", modified: "2026-01-07"},
					{name: "California_Morchella_importuna.ndjson", modified: "2026-01-07"}
				],
				"Morchella brunnea": [
					{name: "Washington_Morchella_brunnea.ndjson", modified: "2026-01-07"},
					{name: "Oregon_Morchella_brunnea.ndjson", modified: "2026-01-07"},
					{name: "California_Morchella_brunnea.ndjson", modified: "2026-01-07"}
				],
				"Morchella norvegiensis": [
					{name: "Washington_Morchella_norvegiensis.ndjson", modified: "2026-01-07"},
					{name: "Oregon_Morchella_norvegiensis.ndjson", modified: "2026-01-07"}
				],
				"Morchella populiphila": [
					{name: "Washington_Morchella_populiphila.ndjson", modified: "2026-01-07"},
					{name: "Oregon_Morchella_populiphila.ndjson", modified: "2026-01-07"},
					{name: "California_Morchella_populiphila.ndjson", modified: "2026-01-07"}
				],
				"Natural Black Morel (Morchella snyderi)": [
					{name: "Washington_Morchella_snyderi.ndjson", modified: "2026-01-07"},
					{name: "Oregon_Morchella_snyderi.ndjson", modified: "2026-01-07"},
					{name: "California_Morchella_snyderi.ndjson", modified: "2026-01-07"}
				],
				"Gray Morel (Morchella tomentosa)": [
					{name: "Washington_Morchella_tomentosa.ndjson", modified: "2026-01-07"},
					{name: "Oregon_Morchella_tomentosa.ndjson", modified: "2026-01-07"},
					{name: "California_Morchella_tomentosa.ndjson", modified: "2026-01-07"}
				],
				"Mountain Blond Morel (Morchella tridentina)": [
					{name: "Washington_Morchella_tridentina.ndjson", modified: "2026-01-07"},
					{name: "Oregon_Morchella_tridentina.ndjson", modified: "2026-01-07"},
					{name: "California_Morchella_tridentina.ndjson", modified: "2026-01-07"}
				],
			}
		};
        
        // Default colors for NDJSON files
		const defaultColors = [
			'#8B4513', '#1E90FF', '#32CD32', '#FF4500', '#9370DB',
			'#FFD700', '#00CED1', '#FF69B4', '#9ACD32', '#FF6347',
			'#8A2BE2', '#DC143C', '#00FA9A', '#FF8C00', '#9932CC',
			'#8FBC8F', '#483D8B', '#2F4F4F', '#D2691E', '#6495ED',
			'#FFF8DC', '#DC143C', '#00FFFF', '#00008B', '#008B8B',
			'#B8860B', '#A9A9A9', '#006400', '#BDB76B', '#8B008B',
			'#556B2F', '#FF8C00', '#9932CC', '#8B0000', '#E9967A'
		];
        
		function formatFolderName(name) {
			// Matches text followed by (something)
			return name.replace(
				/\s*(\([^)]+\))$/,
				' <span class="sci-name">$1</span>'
			);
		}

        // Initialize NDJSON directory
		function initNdjsonDirectory() {
			const directoryContent = document.getElementById('ndjson-folder-structure');
			directoryContent.innerHTML = '';
			
			let colorIndex = 0;
			
			Object.keys(ndjsonStructure).forEach(mainFolderName => {
				const mainFolderDiv = document.createElement('div');
				mainFolderDiv.className = 'folder';
				mainFolderDiv.dataset.folderName = mainFolderName;
				
				// Calculate total files in this main folder
				let mainFolderFileCount = 0;
				Object.keys(ndjsonStructure[mainFolderName]).forEach(subFolderName => {
					mainFolderFileCount += ndjsonStructure[mainFolderName][subFolderName].length;
				});
				
				// Create folder controls for main folder
				const mainFolderControls = createFolderControls(mainFolderName, null, true, false, mainFolderFileCount);
				
				const mainFolderHeader = document.createElement('div');
				mainFolderHeader.className = 'folder-header';
				mainFolderHeader.innerHTML = `
					<div class="folder-name">
						<i class="fas fa-folder"></i>
						<span class="folder-title">${formatFolderName(mainFolderName)}</span>
						<span class="folder-count" style="font-size: 11px; color: #888; background-color: #f0f0f0; padding: 1px 5px; border-radius: 8px; margin-left: 5px;">0 files</span>
					</div>
					</div>
					${mainFolderControls}
					<div class="folder-controls">
						<button class="control-btn folder-select-all" data-folder="${mainFolderName}">All</button>
						<button class="control-btn folder-select-none" data-folder="${mainFolderName}">None</button>
						<button class="toggle-btn folder-toggle">
							<i class="fas fa-chevron-down"></i>
						</button>
					</div>
				`;
				
				const mainFolderContent = document.createElement('div');
				mainFolderContent.className = 'folder-content collapsed';
				mainFolderContent.dataset.folderName = mainFolderName;
				
				Object.keys(ndjsonStructure[mainFolderName]).forEach(subFolderName => {
					const subFolderDiv = document.createElement('div');
					subFolderDiv.className = 'folder';
					subFolderDiv.style.margin = '5px 0';
					subFolderDiv.style.border = '1px solid #eee';
					subFolderDiv.dataset.folderName = mainFolderName;
					subFolderDiv.dataset.subFolderName = subFolderName;
					
					// Get file count for this sub-folder
					const subFolderFileCount = ndjsonStructure[mainFolderName][subFolderName].length;
					
					// Create folder controls for sub-folder
					const isKingBolete = subFolderName.includes('King Bolete (Boletus edulis)');
					const subFolderControls = createFolderControls(mainFolderName, subFolderName, false, isKingBolete, subFolderFileCount);
					
					const subFolderHeader = document.createElement('div');
					subFolderHeader.className = 'folder-header';
					subFolderHeader.style.padding = '5px 10px';
					subFolderHeader.style.backgroundColor = 'var(--slider-bg, #f5f5f5)';
					subFolderHeader.innerHTML = `
						<div class="folder-name">
							<i class="fas fa-folder"></i>
							<span class="folder-title">${formatFolderName(subFolderName)}</span>
							<span class="folder-count" style="font-size: 11px; color: #888; background-color: #f0f0f0; padding: 1px 5px; border-radius: 8px; margin-left: 5px;">0 files</span>
						</div>
						${subFolderControls}
						<div class="folder-controls">
							<button class="control-btn folder-select-all" data-folder="${subFolderName}">All</button>
							<button class="control-btn folder-select-none" data-folder="${subFolderName}">None</button>
							<button class="toggle-btn folder-toggle">
								<i class="fas fa-chevron-down"></i>
							</button>
						</div>
					`;
					
					const subFolderContent = document.createElement('div');
					subFolderContent.className = 'folder-content collapsed';
					subFolderContent.dataset.folderName = mainFolderName;
					subFolderContent.dataset.subFolderName = subFolderName;
					
					ndjsonStructure[mainFolderName][subFolderName].forEach(fileObj => {
						const fileName = fileObj.name;
						const modifiedDate = fileObj.modified;
						const filePath = `ndjson/${mainFolderName}/${subFolderName}/${fileName}`;
						const fileId = filePath.replace(/\//g, '_').replace(/\./g, '_');
						
						// Generate a color for this file
						const fileColor = defaultColors[colorIndex % defaultColors.length];
						colorIndex++;
						
						// Check if this is a Boletus edulis file to enable by default
						const isWashingtonEdulis = fileName === 'Washington_Boletus_edulis.ndjson';
						const isOregonEdulis = fileName === 'Oregon_Boletus_edulis.ndjson';
						const isCaliforniaEdulis = fileName === 'California_Boletus_edulis.ndjson';

						// Enable all three Boletus edulis files by default
						const enableByDefault = isWashingtonEdulis || isOregonEdulis || isCaliforniaEdulis;
						
						// Store initial state - enable Washington_Boletus_edulis.ndjson by default
						activeDatasets[fileId] = {
							active: enableByDefault, // Enable all Boletus edulis files
							color: fileColor,
							pointSize: pointSize,
							filePath: filePath,
							fileName: fileName,
							folderName: mainFolderName,
							subFolderName: subFolderName,
							data: [],
							useFolderColor: false,
							useFolderPointSize: false
						};
						
						const fileDiv = document.createElement('div');
						fileDiv.className = 'ndjson-file';
						fileDiv.dataset.fileId = fileId;
						fileDiv.dataset.folderName = mainFolderName;
						fileDiv.dataset.subFolderName = subFolderName;
						
						// Set up toggle with checkmark if active by default
						const toggleActiveClass = enableByDefault ? 'active' : '';
						const checkmarkDisplay = enableByDefault ? 'block' : 'none';
						
						fileDiv.innerHTML = `
							<div class="file-toggle ${toggleActiveClass}" data-file-id="${fileId}">
								<i class="fas fa-check" style="font-size: 10px; display: ${checkmarkDisplay};"></i>
							</div>

							<div class="file-name-group">
								<div class="file-name" title="${fileName}${modifiedDate ? '\nModified: ' + modifiedDate : ''}">
									${fileName}
								</div>
								<div class="file-count">0</div>
							</div>

							<div class="file-controls">
								<div style="display: flex; align-items: center; gap: 2px;">
									<input type="checkbox" class="color-control-checkbox" data-file-id="${fileId}" ${isKingBolete ? '' : ''} checked>
									<input type="color" class="color-picker" value="${fileColor.substring(0, 7)}" data-file-id="${fileId}" style="min-width: 24px; height: 24px;" ${isKingBolete ? '' : ''}>
									<input type="range" class="alpha-slider" min="0" max="100" value="100" data-file-id="${fileId}" style="width: 60px;" ${isKingBolete ? '' : ''}>
									<span class="alpha-percent" data-file-id="${fileId}" style="font-size: 11px; min-width: 25px;">100%</span>
								</div>

								<div style="display: flex; align-items: center; gap: 2px; margin-left: 20px;">
									<input type="checkbox" class="size-control-checkbox" data-file-id="${fileId}" ${isKingBolete ? '' : ''} checked>
									<input type="number" class="point-size-input" value="${pointSize}" min="1" max="10" data-file-id="${fileId}" style="max-width: 80px; max-height: 30px; font-size: 14px;" ${isKingBolete ? '' : ''}>
								</div>
							</div>
						`;
						
						subFolderContent.appendChild(fileDiv);
					});
					
					subFolderDiv.appendChild(subFolderHeader);
					subFolderDiv.appendChild(subFolderContent);
					mainFolderContent.appendChild(subFolderDiv);
					
					// Add toggle event for sub-folder
					const toggleSubFolder = function(e) {
						if (e) e.stopPropagation(); // Prevent main folder toggle
						const icon = subFolderHeader.querySelector('.folder-toggle i');
						subFolderContent.classList.toggle('collapsed');
						icon.classList.toggle('fa-chevron-up');
						icon.classList.toggle('fa-chevron-down');
					};

					// Click on sub-folder header toggles
					subFolderHeader.addEventListener('click', function(e) {
						// Don't toggle if clicking on control buttons (All/None) or folder controls
						if (!e.target.closest('.folder-controls') && 
							!e.target.closest('.control-btn') &&
							!e.target.closest('.folder-controls-container')) {
							toggleSubFolder(e);
						}
					});

					// Click on toggle button also toggles
					subFolderHeader.querySelector('.folder-toggle').addEventListener('click', toggleSubFolder);
					
					// Add sub-folder select all/none buttons
					subFolderHeader.querySelector('.folder-select-all').addEventListener('click', function(e) {
						e.stopPropagation(); // Prevent folder toggle
						const folder = this.dataset.folder;
						selectAllInSubFolder(mainFolderName, folder, true);
					});
					
					subFolderHeader.querySelector('.folder-select-none').addEventListener('click', function(e) {
						e.stopPropagation(); // Prevent folder toggle
						const folder = this.dataset.folder;
						selectAllInSubFolder(mainFolderName, folder, false);
					});
				});
				
				mainFolderDiv.appendChild(mainFolderHeader);
				mainFolderDiv.appendChild(mainFolderContent);
				directoryContent.appendChild(mainFolderDiv);
				
				// Add toggle event for main folder
				const toggleMainFolder = function() {
					const icon = mainFolderHeader.querySelector('.folder-toggle i');
					mainFolderContent.classList.toggle('collapsed');
					icon.classList.toggle('fa-chevron-up');
					icon.classList.toggle('fa-chevron-down');
				};

				// Click on folder header toggles
				mainFolderHeader.addEventListener('click', function(e) {
					// Don't toggle if clicking on control buttons (All/None) or folder controls
					if (!e.target.closest('.folder-controls') && 
						!e.target.closest('.control-btn') &&
						!e.target.closest('.folder-controls-container')) {
						toggleMainFolder();
					}
				});

				// Click on toggle button also toggles
				mainFolderHeader.querySelector('.folder-toggle').addEventListener('click', toggleMainFolder);
				
				// Add main folder-level select all/none buttons
				mainFolderHeader.querySelector('.folder-select-all').addEventListener('click', function(e) {
					e.stopPropagation(); // Prevent folder toggle
					const folder = this.dataset.folder;
					selectAllInMainFolder(folder, true);
				});
				
				mainFolderHeader.querySelector('.folder-select-none').addEventListener('click', function(e) {
					e.stopPropagation(); // Prevent folder toggle
					const folder = this.dataset.folder;
					selectAllInMainFolder(folder, false);
				});
			});
			
			// Add event listeners for file toggles and controls
			setupFileControls();
			
			// Hide loading message
			document.getElementById('directory-loading').style.display = 'none';
		}

		// Function to update folder file counts based on loaded data
		function updateFolderFileCounts() {
			// Count active files and total data points per folder
			const folderStats = {};
			
			// Initialize with zeros
			Object.keys(ndjsonStructure).forEach(mainFolderName => {
				folderStats[mainFolderName] = { activeFiles: 0, totalPoints: 0 };
				
				Object.keys(ndjsonStructure[mainFolderName]).forEach(subFolderName => {
					const folderKey = `${mainFolderName}_${subFolderName}`;
					folderStats[folderKey] = { activeFiles: 0, totalPoints: 0 };
				});
			});
			
			// Count active files and points
			Object.keys(activeDatasets).forEach(fileId => {
				const fileData = activeDatasets[fileId];
				if (fileData.active) {
					const folderKey = fileData.subFolderName ? 
						`${fileData.folderName}_${fileData.subFolderName}` : 
						fileData.folderName;
					
					if (folderStats[folderKey]) {
						folderStats[folderKey].activeFiles++;
						folderStats[folderKey].totalPoints += fileData.data.length;
					}
					
					// Also update main folder
					if (folderStats[fileData.folderName]) {
						folderStats[fileData.folderName].activeFiles++;
						folderStats[fileData.folderName].totalPoints += fileData.data.length;
					}
				}
			});
			
			// Update folder count displays
			Object.keys(folderStats).forEach(folderKey => {
				const stats = folderStats[folderKey];
				const [folderName, subFolderName] = folderKey.includes('_') ? folderKey.split('_') : [folderKey, null];
				
				// Find the folder header
				let folderHeader;
				if (subFolderName) {
					folderHeader = document.querySelector(`.folder[data-folder-name="${folderName}"][data-sub-folder-name="${subFolderName}"] .folder-header`);
				} else {
					folderHeader = document.querySelector(`.folder[data-folder-name="${folderName}"] .folder-header`);
				}
				
				if (folderHeader) {
					const countElement = folderHeader.querySelector('.folder-count');
					if (countElement) {
						if (stats.totalPoints > 0) {
							countElement.textContent = `${stats.activeFiles} files / ${stats.totalPoints} points`;
						} else {
							countElement.textContent = `${stats.activeFiles} files`;
						}
						
						// Style based on active status
						if (stats.activeFiles > 0) {
							countElement.style.backgroundColor = '#e6f7ff';
							countElement.style.color = '#1890ff';
							countElement.style.fontWeight = '600';
						} else {
							countElement.style.backgroundColor = '#f0f0f0';
							countElement.style.color = '#888';
							countElement.style.fontWeight = 'normal';
						}
					}
				}
			});
		}

		// Helper function to create folder controls
		function createFolderControls(folderName, subFolderName, isMainFolder = false, isKingBolete = false, fileCount = 0, pointCount = 0) {
			const folderKey = subFolderName ? `${folderName}_${subFolderName}` : folderName;
			const controlsId = subFolderName ? `folder-controls-${folderName}-${subFolderName}` : `folder-controls-${folderName}`;
			
			// Generate different colors for each folder
			const folderColors = [
				'#8B4513', '#1E90FF', '#32CD32', '#FF4500', '#9370DB',
				'#FFD700', '#00CED1', '#FF69B4', '#9ACD32', '#FF6347',
				'#8A2BE2', '#DC143C', '#00FA9A', '#FF8C00', '#9932CC'
			];
			
			// Create a consistent hash for the folder to get a color
			const hash = Array.from(folderKey).reduce((acc, char) => {
				return char.charCodeAt(0) + ((acc << 5) - acc);
			}, 0);
			const colorIndex = Math.abs(hash) % folderColors.length;
			const folderColor = folderColors[colorIndex];
			
			// Default: enable King Bolete folder controls
			const colorChecked = isKingBolete ? '' : ''; // Set to 'checked' to make the color or size checked at default
			const sizeChecked = isKingBolete ? '' : '';
			
			return `
				<div class="folder-controls-right-container" style="display: flex; flex-grow: 1; justify-content: flex-end; align-items: center; gap: 15px; margin-right: 10px;">
					<div class="folder-controls-container" id="${controlsId}" style="display: flex; align-items: center; gap: 8px;">
						<div style="display: flex; align-items: center; gap: 2px;">
							<input type="checkbox" class="folder-color-control" 
								data-folder="${folderKey}" ${colorChecked}>
							<input type="color" class="folder-color-picker" 
								data-folder="${folderKey}" value="${folderColor}" style="width: 24px; height: 24px;" ${isKingBolete ? '' : 'disabled'}>
							<input type="range" class="folder-alpha-slider" min="0" max="100" value="100" 
								data-folder="${folderKey}" style="width: 50px;" ${isKingBolete ? '' : 'disabled'}>
							<span class="folder-alpha-percent" data-folder="${folderKey}" style="font-size: 10px;">100%</span>
						</div>
						<div style="display: flex; align-items: center; gap: 2px; margin-left: 20px;">
							<input type="checkbox" class="folder-size-control" 
								data-folder="${folderKey}" ${sizeChecked}>
							<input type="number" class="folder-point-size" value="${pointSize}" min="1" max="10" 
								data-folder="${folderKey}" style="width: 80px; font-size: 12px;" ${isKingBolete ? '' : 'disabled'}>
						</div>
					</div>
				</div>
			`;
		}

		// Setup file controls and event listeners
		function setupFileControls() {
			// File toggle event listeners
			document.querySelectorAll('.file-toggle').forEach(toggle => {
				toggle.addEventListener('click', function() {
					const fileId = this.dataset.fileId;
					const fileData = activeDatasets[fileId];
					
					fileData.active = !fileData.active;
					this.classList.toggle('active');
					this.querySelector('i').style.display = fileData.active ? 'block' : 'none';
					
					if (fileData.active && fileData.data.length === 0) {
						// Load the NDJSON file
						loadNdjsonFile(fileId, fileData.filePath).then(() => {
							// Update folder file counts after loading
							updateFolderFileCounts();
						});
					} else {
						// Just toggle visibility
						updateDataDisplay(false);
						// Update folder file counts
						updateFolderFileCounts();
					}
				});
			});
			
			// Folder control event listeners
			setupFolderControlListeners();
			
			// File control event listeners
			setupFileControlListeners();
		}

		// Setup folder control listeners
		function setupFolderControlListeners() {
			// Folder color control checkboxes
			document.querySelectorAll('.folder-color-control').forEach(checkbox => {
				checkbox.addEventListener('change', function() {
					const folderKey = this.dataset.folder;
					const isChecked = this.checked;
					const [folderName, subFolderName] = folderKey.includes('_') ? folderKey.split('_') : [folderKey, null];
					
					// Enable/disable color picker and alpha slider
					const colorPicker = document.querySelector(`.folder-color-picker[data-folder="${folderKey}"]`);
					const alphaSlider = document.querySelector(`.folder-alpha-slider[data-folder="${folderKey}"]`);
					
					if (colorPicker) colorPicker.disabled = !isChecked;
					if (alphaSlider) alphaSlider.disabled = !isChecked;
					
					// Get current folder color value
					let folderColorValue = null;
					if (isChecked && colorPicker && alphaSlider) {
						const rgb = colorPicker.value;
						const alpha = parseInt(alphaSlider.value);
						const alphaHex = alpha === 100 ? '' : Math.round(alpha * 2.55).toString(16).padStart(2, '0');
						folderColorValue = rgb + alphaHex;
					}
					
					// Update all files in this folder
					updateFilesInFolder(folderName, subFolderName, 'color', isChecked, folderColorValue);
					
					// If enabling folder color, disable individual file color controls in this folder
					if (isChecked) {
						disableFileControlsInFolder(folderName, subFolderName, 'color');
						
						// If this is a main folder (no subfolder), lock all sub-folder checkboxes
						if (!subFolderName) {
							lockSubFolderControls(folderName, 'color', true);
						}
					} else {
						enableFileControlsInFolder(folderName, subFolderName, 'color');
						// When disabling folder color, files should revert to their individual colors
						revertFilesToIndividualColors(folderName, subFolderName);
						
						// If this is a main folder (no subfolder), unlock all sub-folder checkboxes
						if (!subFolderName) {
							lockSubFolderControls(folderName, 'color', false);
						}
					}
					
					// Update display immediately
					updateDataDisplay(true);
				});
			});
			
			// Folder size control checkboxes
			document.querySelectorAll('.folder-size-control').forEach(checkbox => {
				checkbox.addEventListener('change', function() {
					const folderKey = this.dataset.folder;
					const isChecked = this.checked;
					const [folderName, subFolderName] = folderKey.includes('_') ? folderKey.split('_') : [folderKey, null];
					
					// Enable/disable point size input
					const sizeInput = document.querySelector(`.folder-point-size[data-folder="${folderKey}"]`);
					if (sizeInput) sizeInput.disabled = !isChecked;
					
					// Get current folder size value
					let folderSizeValue = null;
					if (isChecked && sizeInput) {
						folderSizeValue = parseInt(sizeInput.value) || pointSize;
					}
					
					// Update all files in this folder
					updateFilesInFolder(folderName, subFolderName, 'size', isChecked, folderSizeValue);
					
					// If enabling folder size, disable individual file size controls in this folder
					if (isChecked) {
						disableFileControlsInFolder(folderName, subFolderName, 'size');
						
						// If this is a main folder (no subfolder), lock all sub-folder checkboxes
						if (!subFolderName) {
							lockSubFolderControls(folderName, 'size', true);
						}
					} else {
						enableFileControlsInFolder(folderName, subFolderName, 'size');
						// When disabling folder size, files should revert to their individual sizes
						revertFilesToIndividualSizes(folderName, subFolderName);
						
						// If this is a main folder (no subfolder), unlock all sub-folder checkboxes
						if (!subFolderName) {
							lockSubFolderControls(folderName, 'size', false);
						}
					}
					
					// Update display immediately
					updateDataDisplay(true);
				});
			});
			
			// Folder color picker and alpha slider
			document.querySelectorAll('.folder-color-picker, .folder-alpha-slider').forEach(input => {
				input.addEventListener('input', function() {
					const folderKey = this.dataset.folder;
					const [folderName, subFolderName] = folderKey.includes('_') ? folderKey.split('_') : [folderKey, null];
					
					// Check if folder color control is enabled
					const folderColorCheckbox = document.querySelector(`.folder-color-control[data-folder="${folderKey}"]`);
					if (!folderColorCheckbox || !folderColorCheckbox.checked) return;
					
					// Get the current values
					const colorPicker = document.querySelector(`.folder-color-picker[data-folder="${folderKey}"]`);
					const alphaSlider = document.querySelector(`.folder-alpha-slider[data-folder="${folderKey}"]`);
					const alphaPercent = document.querySelector(`.folder-alpha-percent[data-folder="${folderKey}"]`);
					
					if (!colorPicker || !alphaSlider) return;
					
					const rgb = colorPicker.value;
					const alpha = parseInt(alphaSlider.value);
					const alphaHex = alpha === 100 ? '' : Math.round(alpha * 2.55).toString(16).padStart(2, '0');
					const finalColor = rgb + alphaHex;
					
					if (alphaPercent) {
						alphaPercent.textContent = alpha + '%';
					}
					
					// Update all files in this folder
					updateFilesInFolder(folderName, subFolderName, 'color', true, finalColor);
					
					// Update display
					updateDataDisplay(true);
				});
			});
			
			// Folder point size input
			document.querySelectorAll('.folder-point-size').forEach(input => {
				makeInputScrollable(input, 1, 10, 1);
				input.addEventListener('input', function() {
					const folderKey = this.dataset.folder;
					const [folderName, subFolderName] = folderKey.includes('_') ? folderKey.split('_') : [folderKey, null];
					
					// Check if folder size control is enabled
					const folderSizeCheckbox = document.querySelector(`.folder-size-control[data-folder="${folderKey}"]`);
					if (!folderSizeCheckbox || !folderSizeCheckbox.checked) return;
					
					const size = parseInt(this.value) || pointSize;
					
					// Update all files in this folder
					updateFilesInFolder(folderName, subFolderName, 'size', true, size);
					
					// Update display
					updateDataDisplay(true);
				});
			});
		}

		function lockSubFolderControls(mainFolderName, type, lock) {
			// Find all sub-folders within this main folder
			const subFolders = document.querySelectorAll(`.folder[data-folder-name="${mainFolderName}"] .folder-header`);
			
			subFolders.forEach(subFolderHeader => {
				const subFolderName = subFolderHeader.closest('.folder').dataset.subFolderName;
				if (subFolderName) {
					const folderKey = `${mainFolderName}_${subFolderName}`;
					
					if (type === 'color') {
						const checkbox = subFolderHeader.querySelector(`.folder-color-control[data-folder="${folderKey}"]`);
						const colorPicker = subFolderHeader.querySelector(`.folder-color-picker[data-folder="${folderKey}"]`);
						const alphaSlider = subFolderHeader.querySelector(`.folder-alpha-slider[data-folder="${folderKey}"]`);
						
						if (checkbox) checkbox.disabled = lock;
						if (colorPicker) colorPicker.disabled = lock;
						if (alphaSlider) alphaSlider.disabled = lock;
						
						// Add visual indicator for disabled state
						if (lock) {
							if (checkbox) checkbox.style.opacity = '0.5';
							if (colorPicker) colorPicker.style.opacity = '0.5';
							if (alphaSlider) alphaSlider.style.opacity = '0.5';
						} else {
							if (checkbox) checkbox.style.opacity = '';
							if (colorPicker) colorPicker.style.opacity = '';
							if (alphaSlider) alphaSlider.style.opacity = '';
							
							// If sub-folder checkbox was previously checked, re-enable it
							if (checkbox && checkbox.checked) {
								if (colorPicker) colorPicker.disabled = false;
								if (alphaSlider) alphaSlider.disabled = false;
							}
						}
					} else if (type === 'size') {
						const checkbox = subFolderHeader.querySelector(`.folder-size-control[data-folder="${folderKey}"]`);
						const sizeInput = subFolderHeader.querySelector(`.folder-point-size[data-folder="${folderKey}"]`);
						
						if (checkbox) checkbox.disabled = lock;
						if (sizeInput) sizeInput.disabled = lock;
						
						// Add visual indicator for disabled state
						if (lock) {
							if (checkbox) checkbox.style.opacity = '0.5';
							if (sizeInput) sizeInput.style.opacity = '0.5';
						} else {
							if (checkbox) checkbox.style.opacity = '';
							if (sizeInput) sizeInput.style.opacity = '';
							
							// If sub-folder checkbox was previously checked, re-enable it
							if (checkbox && checkbox.checked) {
								if (sizeInput) sizeInput.disabled = false;
							}
						}
					}
				}
			});
		}

		// Setup file control listeners
		function setupFileControlListeners() {
			const debouncedUpdate = debounce((fileId) => {
				const colorPicker = document.querySelector(`.color-picker[data-file-id="${fileId}"]`);
				const alphaSlider = document.querySelector(`.alpha-slider[data-file-id="${fileId}"]`);
				const alphaPercent = document.querySelector(`.alpha-percent[data-file-id="${fileId}"]`);
				
				if (!colorPicker || !alphaSlider) return;
				
				const rgb = colorPicker.value;
				const alpha = parseInt(alphaSlider.value);
				const alphaHex = alpha === 100 ? '' : Math.round(alpha * 2.55).toString(16).padStart(2, '0');
				
				// Update only the color in activeDatasets
				activeDatasets[fileId].color = rgb + alphaHex;
				activeDatasets[fileId].useFolderColor = false;
				
				if (alphaPercent) {
					alphaPercent.textContent = alpha + '%';
				}
				
				// Only update visual elements, not reprocess data
				updateDataDisplay(true);
			}, 150);
			
			// File color control checkboxes
			document.querySelectorAll('.color-control-checkbox').forEach(checkbox => {
				checkbox.addEventListener('change', function() {
					const fileId = this.dataset.fileId;
					const isChecked = this.checked;
					
					// Enable/disable color picker and alpha slider
					const colorPicker = document.querySelector(`.color-picker[data-file-id="${fileId}"]`);
					const alphaSlider = document.querySelector(`.alpha-slider[data-file-id="${fileId}"]`);
					
					if (colorPicker) colorPicker.disabled = !isChecked;
					if (alphaSlider) alphaSlider.disabled = !isChecked;
					
					// Update activeDatasets
					if (activeDatasets[fileId]) {
						activeDatasets[fileId].useFolderColor = !isChecked;
						
						// If enabling individual control, get the current color from the picker
						if (isChecked && colorPicker && alphaSlider) {
							const rgb = colorPicker.value;
							const alpha = parseInt(alphaSlider.value);
							const alphaHex = alpha === 100 ? '' : Math.round(alpha * 2.55).toString(16).padStart(2, '0');
							activeDatasets[fileId].color = rgb + alphaHex;
						}
					}
					
					// Update display immediately
					updateDataDisplay(true);
				});
			});
			
			// File size control checkboxes
			document.querySelectorAll('.size-control-checkbox').forEach(checkbox => {
				checkbox.addEventListener('change', function() {
					const fileId = this.dataset.fileId;
					const isChecked = this.checked;
					
					// Enable/disable point size input
					const sizeInput = document.querySelector(`.point-size-input[data-file-id="${fileId}"]`);
					if (sizeInput) sizeInput.disabled = !isChecked;
					
					// Update activeDatasets
					if (activeDatasets[fileId]) {
						activeDatasets[fileId].useFolderPointSize = !isChecked;
						
						// If enabling individual control, get the current size from the input
						if (isChecked && sizeInput) {
							activeDatasets[fileId].pointSize = parseInt(sizeInput.value) || pointSize;
						}
					}
					
					// Update display immediately
					updateDataDisplay(true);
				});
			});
			
			// File point size inputs
			document.querySelectorAll('.point-size-input').forEach(input => {
				makeInputScrollable(input, 1, 10, 1);
				input.addEventListener('input', function() {
					const fileId = this.dataset.fileId;
					const size = parseInt(this.value) || pointSize;
					
					if (activeDatasets[fileId]) {
						activeDatasets[fileId].pointSize = size;
						activeDatasets[fileId].useFolderPointSize = false;
						updateVisualsOnly();
					}
				});
			});

			// Add event listeners for global point size controls
			document.getElementById('user-point-size').addEventListener('input', function() {
				userPointSize = parseInt(this.value) || 5;
				updateDataDisplay(true);
			});

			document.getElementById('highlight-point-size').addEventListener('input', function() {
				highlightPointSize = parseInt(this.value) || 5;
				updateDataDisplay(true);
			});
			
			// File color pickers and alpha sliders
			document.querySelectorAll('.color-picker, .alpha-slider').forEach(input => {
				input.addEventListener('input', function() {
					const fileId = this.dataset.fileId;
					debouncedUpdate(fileId);
				});
			});
			
			// Global select all/none buttons
			document.getElementById('select-all-btn').addEventListener('click', function() {
				selectAllFiles(true);
			});
			
			document.getElementById('select-none-btn').addEventListener('click', function() {
				selectAllFiles(false);
			});
		}

		// Helper function to revert files to individual colors
		function revertFilesToIndividualColors(folderName, subFolderName) {
			const selector = subFolderName 
				? `.ndjson-file[data-folder-name="${folderName}"][data-sub-folder-name="${subFolderName}"]`
				: `.ndjson-file[data-folder-name="${folderName}"]`;
			
			document.querySelectorAll(selector).forEach(fileDiv => {
				const fileId = fileDiv.dataset.fileId;
				const fileData = activeDatasets[fileId];
				
				if (fileData) {
					// First check if main folder has color enabled
					const mainFolderColorCheckbox = document.querySelector(`.folder-color-control[data-folder="${fileData.folderName}"]`);
					if (mainFolderColorCheckbox && mainFolderColorCheckbox.checked) {
						// Use main folder color
						const folderColorPicker = document.querySelector(`.folder-color-picker[data-folder="${fileData.folderName}"]`);
						const folderAlphaSlider = document.querySelector(`.folder-alpha-slider[data-folder="${fileData.folderName}"]`);
						
						if (folderColorPicker && folderAlphaSlider) {
							const rgb = folderColorPicker.value;
							const alpha = parseInt(folderAlphaSlider.value);
							const alphaHex = alpha === 100 ? '' : Math.round(alpha * 2.55).toString(16).padStart(2, '0');
							fileData.color = rgb + alphaHex;
							fileData.useFolderColor = true;
						}
						return; // Skip checking sub-folders if main folder is enabled
					}
					
					// Check if this file is in a sub-folder that has its own enabled color
					const subFolderKey = `${fileData.folderName}_${fileData.subFolderName}`;
					const subFolderColorCheckbox = document.querySelector(`.folder-color-control[data-folder="${subFolderKey}"]`);
					
					if (subFolderColorCheckbox && subFolderColorCheckbox.checked) {
						// Use sub-folder color instead of individual file color
						const folderColorPicker = document.querySelector(`.folder-color-picker[data-folder="${subFolderKey}"]`);
						const folderAlphaSlider = document.querySelector(`.folder-alpha-slider[data-folder="${subFolderKey}"]`);
						
						if (folderColorPicker && folderAlphaSlider) {
							const rgb = folderColorPicker.value;
							const alpha = parseInt(folderAlphaSlider.value);
							const alphaHex = alpha === 100 ? '' : Math.round(alpha * 2.55).toString(16).padStart(2, '0');
							fileData.color = rgb + alphaHex;
							fileData.useFolderColor = true;
						}
					} else {
						// Get the individual color from the file's color picker
						const colorPicker = fileDiv.querySelector('.color-picker');
						const alphaSlider = fileDiv.querySelector('.alpha-slider');
						
						if (colorPicker && alphaSlider) {
							const rgb = colorPicker.value;
							const alpha = parseInt(alphaSlider.value);
							const alphaHex = alpha === 100 ? '' : Math.round(alpha * 2.55).toString(16).padStart(2, '0');
							fileData.color = rgb + alphaHex;
							fileData.useFolderColor = false;
						}
					}
				}
			});
		}

		// Helper function to revert files to individual sizes
		function revertFilesToIndividualSizes(folderName, subFolderName) {
			const selector = subFolderName 
				? `.ndjson-file[data-folder-name="${folderName}"][data-sub-folder-name="${subFolderName}"]`
				: `.ndjson-file[data-folder-name="${folderName}"]`;
			
			document.querySelectorAll(selector).forEach(fileDiv => {
				const fileId = fileDiv.dataset.fileId;
				const fileData = activeDatasets[fileId];
				
				if (fileData) {
					// First check if main folder has size enabled
					const mainFolderSizeCheckbox = document.querySelector(`.folder-size-control[data-folder="${fileData.folderName}"]`);
					if (mainFolderSizeCheckbox && mainFolderSizeCheckbox.checked) {
						// Use main folder size
						const folderSizeInput = document.querySelector(`.folder-point-size[data-folder="${fileData.folderName}"]`);
						if (folderSizeInput) {
							fileData.pointSize = parseInt(folderSizeInput.value) || pointSize;
							fileData.useFolderPointSize = true;
						}
						return; // Skip checking sub-folders if main folder is enabled
					}
					
					// Check if this file is in a sub-folder that has its own enabled size
					const subFolderKey = `${fileData.folderName}_${fileData.subFolderName}`;
					const subFolderSizeCheckbox = document.querySelector(`.folder-size-control[data-folder="${subFolderKey}"]`);
					
					if (subFolderSizeCheckbox && subFolderSizeCheckbox.checked) {
						// Use sub-folder size instead of individual file size
						const folderSizeInput = document.querySelector(`.folder-point-size[data-folder="${subFolderKey}"]`);
						if (folderSizeInput) {
							fileData.pointSize = parseInt(folderSizeInput.value) || pointSize;
							fileData.useFolderPointSize = true;
						}
					} else {
						// Get the individual size from the file's size input
						const sizeInput = fileDiv.querySelector('.point-size-input');
						if (sizeInput) {
							fileData.pointSize = parseInt(sizeInput.value) || pointSize;
							fileData.useFolderPointSize = false;
						}
					}
				}
			});
		}

		// Helper function to update files in a folder
		function updateFilesInFolder(folderName, subFolderName, type, useFolderValue, value = null) {
			Object.keys(activeDatasets).forEach(fileId => {
				const fileData = activeDatasets[fileId];
				
				// Check if file belongs to this folder
				const inFolder = subFolderName 
					? fileData.folderName === folderName && fileData.subFolderName === subFolderName
					: fileData.folderName === folderName;
				
				if (inFolder) {
					if (type === 'color') {
						fileData.useFolderColor = useFolderValue;
						if (useFolderValue && value !== null) {
							fileData.color = value;
						} else if (!useFolderValue) {
							// When not using folder color, revert to individual color
							// This will be handled by revertFilesToIndividualColors
						}
					} else if (type === 'size') {
						fileData.useFolderPointSize = useFolderValue;
						if (useFolderValue && value !== null) {
							fileData.pointSize = value;
						} else if (!useFolderValue) {
							// When not using folder size, revert to individual size
							// This will be handled by revertFilesToIndividualSizes
						}
					}
				}
			});
		}

		// Helper function to disable file controls in a folder
		function disableFileControlsInFolder(folderName, subFolderName, type) {
			const selector = subFolderName 
				? `.ndjson-file[data-folder-name="${folderName}"][data-sub-folder-name="${subFolderName}"]`
				: `.ndjson-file[data-folder-name="${folderName}"]`;
			
			document.querySelectorAll(selector).forEach(fileDiv => {
				const fileId = fileDiv.dataset.fileId;
				
				if (type === 'color') {
					const checkbox = fileDiv.querySelector('.color-control-checkbox');
					const colorPicker = fileDiv.querySelector('.color-picker');
					const alphaSlider = fileDiv.querySelector('.alpha-slider');
					
					if (checkbox) checkbox.disabled = true;
					if (colorPicker) colorPicker.disabled = true;
					if (alphaSlider) alphaSlider.disabled = true;
				} else if (type === 'size') {
					const checkbox = fileDiv.querySelector('.size-control-checkbox');
					const sizeInput = fileDiv.querySelector('.point-size-input');
					
					if (checkbox) checkbox.disabled = true;
					if (sizeInput) sizeInput.disabled = true;
				}
			});
		}

		// Helper function to enable file controls in a folder
		function enableFileControlsInFolder(folderName, subFolderName, type) {
			const selector = subFolderName 
				? `.ndjson-file[data-folder-name="${folderName}"][data-sub-folder-name="${subFolderName}"]`
				: `.ndjson-file[data-folder-name="${folderName}"]`;
			
			document.querySelectorAll(selector).forEach(fileDiv => {
				const fileId = fileDiv.dataset.fileId;
				
				if (type === 'color') {
					const checkbox = fileDiv.querySelector('.color-control-checkbox');
					const colorPicker = fileDiv.querySelector('.color-picker');
					const alphaSlider = fileDiv.querySelector('.alpha-slider');
					
					if (checkbox) checkbox.disabled = false;
					if (colorPicker) colorPicker.disabled = false;
					if (alphaSlider) alphaSlider.disabled = false;
				} else if (type === 'size') {
					const checkbox = fileDiv.querySelector('.size-control-checkbox');
					const sizeInput = fileDiv.querySelector('.point-size-input');
					
					if (checkbox) checkbox.disabled = false;
					if (sizeInput) sizeInput.disabled = false;
				}
			});
		}

		// Add these helper functions to your JavaScript
		function selectAllInFolder(folderName, select) {
			Object.keys(activeDatasets).forEach(fileId => {
				const fileData = activeDatasets[fileId];
				if (fileData.folderName === folderName) {
					fileData.active = select;
					
					// Update the UI toggle
					const toggle = document.querySelector(`.file-toggle[data-file-id="${fileId}"]`);
					if (toggle) {
						toggle.classList.toggle('active', select);
						toggle.querySelector('i').style.display = select ? 'block' : 'none';
					}
					
					// Load data if selecting and not loaded yet
					if (select && fileData.data.length === 0) {
						loadNdjsonFile(fileId, fileData.filePath);
					}
				}
			});
			
			// Update the display
			updateDataDisplay(false);
		}

		function selectAllFiles(select) {
			Object.keys(activeDatasets).forEach(fileId => {
				const fileData = activeDatasets[fileId];
				fileData.active = select;
				
				// Update the UI toggle
				const toggle = document.querySelector(`.file-toggle[data-file-id="${fileId}"]`);
				if (toggle) {
					toggle.classList.toggle('active', select);
					toggle.querySelector('i').style.display = select ? 'block' : 'none';
				}
				
				// Load data if selecting and not loaded yet
				if (select && fileData.data.length === 0) {
					loadNdjsonFile(fileId, fileData.filePath);
				}
			});
			
			// Update the display
			updateDataDisplay(false);
		}

		function selectAllInMainFolder(mainFolderName, select) {
			Object.keys(activeDatasets).forEach(fileId => {
				const fileData = activeDatasets[fileId];
				if (fileData.folderName === mainFolderName) {
					fileData.active = select;
					
					// Update the UI toggle
					const toggle = document.querySelector(`.file-toggle[data-file-id="${fileId}"]`);
					if (toggle) {
						toggle.classList.toggle('active', select);
						toggle.querySelector('i').style.display = select ? 'block' : 'none';
					}
					
					// Load data if selecting and not loaded yet
					if (select && fileData.data.length === 0) {
						loadNdjsonFile(fileId, fileData.filePath).then(() => {
							updateFolderFileCounts();
						});
					} else {
						updateFolderFileCounts();
					}
				}
			});
			
			// Update the display
			updateDataDisplay(false);
		}

		function selectAllInSubFolder(mainFolderName, subFolderName, select) {
			Object.keys(activeDatasets).forEach(fileId => {
				const fileData = activeDatasets[fileId];
				if (fileData.folderName === mainFolderName && fileData.subFolderName === subFolderName) {
					fileData.active = select;
					
					// Update the UI toggle
					const toggle = document.querySelector(`.file-toggle[data-file-id="${fileId}"]`);
					if (toggle) {
						toggle.classList.toggle('active', select);
						toggle.querySelector('i').style.display = select ? 'block' : 'none';
					}
					
					// Load data if selecting and not loaded yet
					if (select && fileData.data.length === 0) {
						loadNdjsonFile(fileId, fileData.filePath).then(() => {
							updateFolderFileCounts();
						});
					} else {
						updateFolderFileCounts();
					}
				}
			});
			
			// Update the display
			updateDataDisplay(false);
		}
        
        // Load NDJSON file
		async function loadNdjsonFile(fileId, filePath) {
			try {
				const response = await fetch(filePath);
				if (!response.ok) {
					throw new Error(`Failed to load ${filePath}: ${response.status}`);
				}
				
				const text = await response.text();
				const lines = text.trim().split('\n');
				const data = lines.map(line => JSON.parse(line));
				
				// Store the data
				activeDatasets[fileId].data = data;
				
				// Check if folder color should be applied
				const fileData = activeDatasets[fileId];
				const folderKey = fileData.subFolderName ? 
					`${fileData.folderName}_${fileData.subFolderName}` : 
					fileData.folderName;
				
				const folderColorCheckbox = document.querySelector(`.folder-color-control[data-folder="${folderKey}"]`);
				if (folderColorCheckbox && folderColorCheckbox.checked) {
					// Apply folder color
					const folderColorPicker = document.querySelector(`.folder-color-picker[data-folder="${folderKey}"]`);
					const folderAlphaSlider = document.querySelector(`.folder-alpha-slider[data-folder="${folderKey}"]`);
					
					if (folderColorPicker && folderAlphaSlider) {
						const rgb = folderColorPicker.value;
						const alpha = parseInt(folderAlphaSlider.value);
						const alphaHex = alpha === 100 ? '' : Math.round(alpha * 2.55).toString(16).padStart(2, '0');
						activeDatasets[fileId].color = rgb + alphaHex;
						activeDatasets[fileId].useFolderColor = true;
					}
				}
				
				// Check if folder size should be applied
				const folderSizeCheckbox = document.querySelector(`.folder-size-control[data-folder="${folderKey}"]`);
				if (folderSizeCheckbox && folderSizeCheckbox.checked) {
					// Apply folder size
					const folderSizeInput = document.querySelector(`.folder-point-size[data-folder="${folderKey}"]`);
					if (folderSizeInput) {
						activeDatasets[fileId].pointSize = parseInt(folderSizeInput.value) || pointSize;
						activeDatasets[fileId].useFolderPointSize = true;
					}
				}
				
				// Update count display
				const fileElement = document.querySelector(`.ndjson-file[data-file-id="${fileId}"]`);
				if (fileElement) {
					fileElement.querySelector('.file-count').textContent = data.length;
				}
				
				// Update the display
				updateDataDisplay();

				// Update folder file counts
				updateFolderFileCounts();
				
			} catch (error) {
				console.error(`Error loading NDJSON file ${filePath}:`, error);
				alert(`Error loading ${filePath}: ${error.message}`);
				
				// Deactivate the file
				activeDatasets[fileId].active = false;
				const toggle = document.querySelector(`.file-toggle[data-file-id="${fileId}"]`);
				if (toggle) {
					toggle.classList.remove('active');
					toggle.querySelector('i').style.display = 'none';
				}
			}
		}
        
        // Process NDJSON data based on current settings
		function processNdjsonData() {
			chartData = [];
			originalData = [];
			
			// Process each active NDJSON file
			Object.keys(activeDatasets).forEach(fileId => {
				const fileData = activeDatasets[fileId];
				
				if (fileData.active && fileData.data.length > 0) {
					fileData.data.forEach(record => {
						// Calculate averages based on settings
						const daysToAverage = Math.min(averageDays, record.dates.length);
						const startIdx = record.dates.length - daysToAverage;
						
						// Get soil temperature data for selected depth
						const tempData = record.soil_temperature[tempDepth];
						const avgTemp = tempData && tempData.length > 0 ?
							tempData.slice(startIdx).reduce((sum, val) => sum + val, 0) / daysToAverage :
							null;
						
						// Get soil moisture data for selected depth
						const moistureData = record.soil_moisture[moistureDepth];
						const avgMoisture = moistureData && moistureData.length > 0 ?
							moistureData.slice(startIdx).reduce((sum, val) => sum + val, 0) / daysToAverage :
							null;
						
						// Parse date
						const date = new Date(record.date_used);
						const month = date.getMonth() + 1;
						const monthDay = date.getDate();
						const monthFraction = month + (monthDay / 31);
						
						// Create data point
						const dataPoint = {
							datasetId: fileId,
							datasetName: fileData.fileName,
							datasetColor: fileData.color,
							observationUrl: record.observation_url,
							date: record.date_used,
							coordinates: record.coordinates,
							elevationFt: record.aws_elevation_ft || record.elevation_ft, // Use aws_elevation_ft if available
							soilTemp: avgTemp,
							soilMoisture: avgMoisture,
							month: month,
							monthName: date.toLocaleString('default', { month: 'short' }),
							monthDay: monthDay,
							monthFraction: monthFraction,
							yearMonth: date.getFullYear() + '-' + String(month).padStart(2, '0'),
							latitude: parseFloat(record.coordinates.split(',')[0]),
							longitude: parseFloat(record.coordinates.split(',')[1]),
							slopeDeg: record.slope_deg, // Add slope degree
							slopeAspectDeg: record.slope_aspect_deg, // Add slope aspect
							rawData: record
						};
						
						chartData.push(dataPoint);
						originalData.push(dataPoint);
					});
				}
			});
			
			// Combine with user data
			allData = [...originalData, ...userData];
		}
        
        // Update all charts and map with current data
		function updateDataDisplay(updateVisualsOnlyFlag = false) {
			if (!updateVisualsOnlyFlag) {
				// Only process data if needed (when loading new files or changing settings)
				processNdjsonData();
				populateDataTable(); // Only needed when data changes
				updateCharts(); // Full chart update with new data
				updateHistogram(); // Update histogram with new data
				// Create map points with fresh data
				updateMapPoints(); // This will create the initial markers
			} else {
				// Just update colors/visuals AND sizes
				updateChartColors();
				updateVisualsOnly(); // This will update histogram colors too AND map points
			}
		}
        
        // Initialize map
		function initMap() {
			map = L.map('map').setView([46.744487, -121.812952], 6);
			
			// Set initial tile layer
			updateTileLayer();
			
			// Add click event to map
			map.on('click', function(e) {
				const clickedElement = e.originalEvent.target;
				const isControl = clickedElement.closest('.map-controls') || 
								 clickedElement.closest('.noUi-handle') ||
								 clickedElement.closest('.fullscreen-btn') ||
								 clickedElement.closest('.map-theme-toggle');
				
				if (!isControl) {
					document.getElementById('latitude').value = e.latlng.lat.toFixed(6);
					document.getElementById('longitude').value = e.latlng.lng.toFixed(6);
					
					if (marker) {
						map.removeLayer(marker);
					}
					marker = L.marker(e.latlng).addTo(map);
				}
			});
			
			// Create map controls
			const mapControls = L.control({position: 'topright'});
			mapControls.onAdd = function() {
				const div = L.DomUtil.create('div', 'map-controls');
				
				L.DomEvent.disableClickPropagation(div);
				
				// Create HTML for layer selector with optgroups
				const layerSelectHTML = `
					<div id="layer-controls" style="margin-top: 10px; display: none;">
						<label style="font-size: 12px; font-weight: bold; display: block; margin-bottom: 5px;">Map Style:</label>
						<select id="layer-selector" style="width: 100%; padding: 5px; font-size: 12px;">
							<optgroup label="Watercolor">
								<option value="watercolor">Stamen Watercolor</option>
								<option value="watercolor_muted">Watercolor Muted</option>
								<option value="watercolor_gray">Watercolor Gray</option>
								<option value="watercolor_darkgray">Watercolor Dark Gray</option>
							</optgroup>
							<optgroup label="OpenStreetMap">
								<option value="osm_std">OpenStreetMap Standard</option>
								<option value="osm_de">OpenStreetMap DE</option>
								<option value="osm_fr">OpenStreetMap FR</option>
								<option value="osm_hot">OpenStreetMap HOT</option>
								<option value="osm_lightgray">OSM Light Gray</option>
								<option value="osm_medgray">OSM Medium Gray</option>
								<option value="osm_medgray2">OSM Medium Gray 2</option>
								<option value="osm_darkgray">OSM Dark Gray</option>
								<option value="osm_darkest">OSM Darkest</option>
							</optgroup>
							<optgroup label="Topographic">
								<option value="otm">OpenTopoMap</option>
								<option value="otm_muted">OpenTopoMap Muted</option>
								<option value="eox_terrain">EOX Terrain</option>
								<option value="eox_terrain_light">EOX Terrain Light</option>
								<option value="usgs_topo">USGS Topo</option>
								<option value="usgs_hillshade">USGS Hillshade</option>
								<option value="usgs_aspect">USGS Aspect Map</option>
								<option value="usgs_slope">USGS Slope Map</option>
							</optgroup>
							<optgroup label="Satellite & Imagery">
								<option value="eox_blackmarble">EOX Black Marble</option>
								<option value="eox_bluemarble">EOX Blue Marble</option>
								<option value="sentinel_2024">Sentinel-2 2024</option>
								<option value="usgs_img">USGS Imagery</option>
								<option value="usgs_imgtopo">USGS Imagery+Topo</option>
							</optgroup>
						</select>
						<div style="margin-top: 10px; display: flex; gap: 5px;">
							<button id="quick-dark" style="flex: 1; padding: 3px; font-size: 10px;">Dark Map</button>
							<button id="quick-light" style="flex: 1; padding: 3px; font-size: 10px;">Light Map</button>
						</div>
					</div>
				`;
				
				div.innerHTML = `
					<div class="view-options">
						<button class="active" data-view="default">Default</button>
						<button data-view="elevation">Elevation</button>
						<button data-view="temp">Soil Temp</button>
						<button data-view="moisture">Soil Moisture</button>
						<button data-view="slope">Slope</button>
						<button data-view="aspect">Aspect</button>
						<button data-view="month">Date</button>
					</div>
					${layerSelectHTML}
					<div id="elevation-slider" class="slider-container">
						<label>Elevation Range (ft)</label>
						<div id="elevation-slider-range" class="range-slider"></div>
						<div class="range-values">
							<span id="elevation-min">0</span>
							<span>-</span>
							<span id="elevation-max">12000</span>
						</div>
					</div>
					<div id="temp-slider" class="slider-container">
						<label>Soil Temp Range (¬∞F)</label>
						<div id="temp-slider-range" class="range-slider"></div>
						<div class="range-values">
							<span id="temp-min">30</span>
							<span>-</span>
							<span id="temp-max">70</span>
						</div>
					</div>
					<div id="moisture-slider" class="slider-container">
						<label>Soil Moisture Range</label>
						<div id="moisture-slider-range" class="range-slider"></div>
						<div class="range-values">
							<span id="moisture-min">0</span>
							<span>-</span>
							<span id="moisture-max">0.5</span>
						</div>
					</div>
					<!-- Regular slope slider -->
					<div id="slope-slider" class="slider-container">
						<label>Slope Range (degrees)</label>
						<div id="slope-slider-range" class="range-slider"></div>
						<div class="range-values">
							<span id="slope-min">0</span>
							<span>-</span>
							<span id="slope-max">90</span>
						</div>
					</div>
					<!-- Circular aspect slider -->
					<div id="aspect-slider" class="slider-container">
						<label>Aspect Range (degrees)</label>
						<div class="aspect-circular-container">
							<div class="aspect-inputs">
								<div class="aspect-input">
									<label>Start:</label>
									<input type="number" id="aspect-start" min="0" max="360" step="1" value="0">
									<span>¬∞</span>
								</div>
								<span>to</span>
								<div class="aspect-input">
									<label>End:</label>
									<input type="number" id="aspect-end" min="0" max="360" step="1" value="359">
									<span>¬∞</span>
								</div>
							</div>
							<div class="aspect-circle" id="aspect-circle">
								<div class="aspect-center"></div>
								
								<!-- Main compass directions -->
								<div class="aspect-compass north">N</div>
								<div class="aspect-compass east">E</div>
								<div class="aspect-compass south">S</div>
								<div class="aspect-compass west">W</div>
								
								<!-- Intermediate directions -->
								<div class="aspect-compass northeast">NE</div>
								<div class="aspect-compass southeast">SE</div>
								<div class="aspect-compass southwest">SW</div>
								<div class="aspect-compass northwest">NW</div>
								
								<!-- Degree markers -->
								<div class="aspect-degree zero">0¬∞</div>
								<div class="aspect-degree ninety">90¬∞</div>
								<div class="aspect-degree one-eighty">180¬∞</div>
								<div class="aspect-degree two-seventy">270¬∞</div>
								
								<!-- Selected range overlay -->
								<div class="aspect-selected-overlay" id="aspect-selected-overlay"></div>
								
								<!-- Handles -->
								<div class="aspect-handle start" id="aspect-handle-start"></div>
								<div class="aspect-handle end" id="aspect-handle-end"></div>
							</div>
						</div>
					</div>
					<div id="month-slider" class="slider-container">
						<label>Date Range</label>
						<div id="month-slider-range" class="range-slider"></div>
						<div class="range-values">
							<span id="month-min">Jan</span>
							<span>-</span>
							<span id="month-max">Dec</span>
						</div>
					</div>
				`;
                
                // Fullscreen button
				const fullscreenBtn = L.DomUtil.create('button', 'fullscreen-btn', map.getContainer());
				fullscreenBtn.textContent = 'Fullscreen';
				L.DomEvent.on(fullscreenBtn, 'click', toggleFullscreen);
				L.DomEvent.disableClickPropagation(fullscreenBtn);
				
				// Add map theme toggle button
				const mapThemeToggle = L.DomUtil.create('button', 'map-theme-toggle', map.getContainer());
				mapThemeToggle.innerHTML = '<i class="fas fa-layer-group"></i> Layers';
				mapThemeToggle.title = 'Toggle map layers';
				L.DomEvent.on(mapThemeToggle, 'click', function() {
					const layerControls = document.getElementById('layer-controls');
					layerControls.style.display = layerControls.style.display === 'none' ? 'block' : 'none';
				});
				L.DomEvent.disableClickPropagation(mapThemeToggle);
				
				// View option click handlers
				div.querySelectorAll('.view-options button').forEach(btn => {
					btn.addEventListener('click', function() {
						div.querySelectorAll('.view-options button').forEach(b => b.classList.remove('active'));
						this.classList.add('active');
						currentView = this.dataset.view;
						
						updateAllSliderBackgrounds();
						updateMapPoints();
					});
				});
				
				// Layer selector change handler
				const layerSelector = div.querySelector('#layer-selector');
				if (layerSelector) {
					layerSelector.value = currentBaseLayer;
					layerSelector.addEventListener('change', function() {
						currentBaseLayer = this.value;
						updateTileLayer();
						localStorage.setItem('mapLayer', currentBaseLayer);
					});
				}
				
				// Quick dark/light buttons
				div.querySelector('#quick-dark').addEventListener('click', function() {
					// Pick a random dark map
					const darkMaps = layerGroups.dark;
					const randomDarkMap = darkMaps[Math.floor(Math.random() * darkMaps.length)];
					currentBaseLayer = randomDarkMap;
					layerSelector.value = randomDarkMap;
					updateTileLayer();
					localStorage.setItem('mapLayer', currentBaseLayer);
				});
				
				div.querySelector('#quick-light').addEventListener('click', function() {
					// Pick a random light map
					const lightMaps = layerGroups.light;
					const randomLightMap = lightMaps[Math.floor(Math.random() * lightMaps.length)];
					currentBaseLayer = randomLightMap;
					layerSelector.value = randomLightMap;
					updateTileLayer();
					localStorage.setItem('mapLayer', currentBaseLayer);
				});
				
				return div;
			};
			
			mapControls.addTo(map);
			
			// Initialize sliders (keep existing code...)
			setTimeout(() => {
				window.elevationSlider = createRangeSlider('elevation-slider-range', 0, 12000, [0, 12000], 100);
				window.tempSlider = createRangeSlider('temp-slider-range', 30, 70, [30, 70], 1);
				window.moistureSlider = createRangeSlider('moisture-slider-range', 0, 0.5, [0, 0.5], 0.01);
				window.slopeSlider = createRangeSlider('slope-slider-range', 0, 90, [0, 90], 1);
				window.monthSlider = createRangeSlider('month-slider-range', 1, 365, [1, 365], 1);
				
				initCircularAspectSlider();
				
				// Set initial gradient backgrounds
				updateSliderBackground(window.elevationSlider, 'elevation');
				updateSliderBackground(window.tempSlider, 'temp');
				updateSliderBackground(window.moistureSlider, 'moisture');
				updateSliderBackground(window.slopeSlider, 'slope');
				updateSliderBackground(window.monthSlider, 'month');
				
				// Existing slider update handlers...
				window.elevationSlider.on('update', function(values) {
					elevationRange = values.map(v => parseFloat(v));
					document.getElementById('elevation-min').textContent = Math.round(values[0]);
					document.getElementById('elevation-max').textContent = Math.round(values[1]);
					updateMapPoints();
				});
				
				window.tempSlider.on('update', function(values) {
					tempRange = values.map(v => parseFloat(v));
					document.getElementById('temp-min').textContent = Math.round(values[0]);
					document.getElementById('temp-max').textContent = Math.round(values[1]);
					updateMapPoints();
				});
				
				window.moistureSlider.on('update', function(values) {
					moistureRange = values.map(v => parseFloat(v));
					document.getElementById('moisture-min').textContent = parseFloat(values[0]).toFixed(2);
					document.getElementById('moisture-max').textContent = parseFloat(values[1]).toFixed(2);
					updateMapPoints();
				});
				
				window.slopeSlider.on('update', function(values) {
					slopeRange = values.map(v => parseFloat(v));
					document.getElementById('slope-min').textContent = Math.round(values[0]);
					document.getElementById('slope-max').textContent = Math.round(values[1]);
					updateMapPoints();
				});
				
				window.monthSlider.on('update', function(values) {
					monthRange = values.map(v => Math.round(parseFloat(v)));
					updateMonthLabels();
					updateMapPoints();
				});
				
				updateMonthLabels();
				updateMapPoints();
			}, 100);
		}

		// Function to update tile layer
		function updateTileLayer() {
			// Remove existing tile layers
			map.eachLayer(function(layer) {
				if (layer instanceof L.TileLayer) {
					map.removeLayer(layer);
				}
			});
			
			// Get and add new tile layer
			const layerConfig = tileLayers[currentBaseLayer];
			if (layerConfig && layerConfig.layer) {
				layerConfig.layer.addTo(map);
			} else {
				// Fallback to OSM if layer not found
				tileLayers.osm_std.layer.addTo(map);
				currentBaseLayer = 'osm_std';
			}
			
			// Update map container class for theme-specific styling
			const mapContainer = document.querySelector('.map-container');
			const mapDiv = map.getContainer();
			
			// Clear any existing filter styles
			mapDiv.style.filter = '';
			mapDiv.style.webkitFilter = '';
			mapContainer.classList.remove('dark', 'light');
			
			// Check if this is a dark map
			const isDarkMap = layerGroups.dark.includes(currentBaseLayer);
			
			if (isDarkMap) {
				mapContainer.classList.add('dark');
				// Apply a subtle darkening filter to the entire map container
				mapDiv.style.filter = 'brightness(0.9) contrast(1.1)';
				mapDiv.style.webkitFilter = 'brightness(0.9) contrast(1.1)';
				darkMode = true;
			} else {
				mapContainer.classList.add('light');
				darkMode = false;
			}
		}

		function initCircularAspectSlider() {
			const circle = document.getElementById('aspect-circle');
			const startHandle = document.getElementById('aspect-handle-start');
			const endHandle = document.getElementById('aspect-handle-end');
			const startInput = document.getElementById('aspect-start');
			const endInput = document.getElementById('aspect-end');
			const selectedOverlay = document.getElementById('aspect-selected-overlay');
			
			if (!circle || !startHandle || !endHandle || !startInput || !endInput || !selectedOverlay) return;
			
			const radius = 100; // Half of 200px
			const centerX = 100;
			const centerY = 100;
			
			function updateHandlePosition(handle, angle) {
				const radians = (angle - 90) * (Math.PI / 180); // -90 to make 0¬∞ at top
				const x = centerX + radius * Math.cos(radians);
				const y = centerY + radius * Math.sin(radians);
				handle.style.left = x + 'px';
				handle.style.top = y + 'px';
			}
			
			function updateFromInputs() {
				let startAngle = parseFloat(startInput.value) || 0;
				let endAngle = parseFloat(endInput.value) || 360;
				
				// Normalize angles to 0-360
				startAngle = ((startAngle % 360) + 360) % 360;
				endAngle = ((endAngle % 360) + 360) % 360;
				
				// Update handle positions
				updateHandlePosition(startHandle, startAngle);
				updateHandlePosition(endHandle, endAngle);
				
				// Update aspect range
				aspectRange = [startAngle, endAngle];
				
				// Update the selected range visualization
				updateSelectedRange(startAngle, endAngle);
				
				// Update map points
				updateMapPoints();
			}
			
			function updateSelectedRange(start, end) {
				// Create a conic gradient for the selected range
				let gradientStops = '';
				
				if (end > start) {
					// Normal range (no wrap)
					gradientStops = `
						transparent 0deg,
						transparent ${start}deg,
						rgba(139, 69, 19, 0.3) ${start}deg,
						rgba(139, 69, 19, 0.3) ${end}deg,
						transparent ${end}deg,
						transparent 360deg
					`;
				} else {
					// Wrapped range (e.g., 300¬∞ to 60¬∞)
					gradientStops = `
						rgba(139, 69, 19, 0.3) 0deg,
						rgba(139, 69, 19, 0.3) ${end}deg,
						transparent ${end}deg,
						transparent ${start}deg,
						rgba(139, 69, 19, 0.3) ${start}deg,
						rgba(139, 69, 19, 0.3) 360deg
					`;
				}
				
				selectedOverlay.style.background = `conic-gradient(${gradientStops})`;
				
				// Add a border to the selected section
				selectedOverlay.style.border = '2px solid #8B4513';
				selectedOverlay.style.boxSizing = 'border-box';
			}
			
			function getAngleFromPosition(x, y) {
				const dx = x - centerX;
				const dy = y - centerY;
				let angle = Math.atan2(dy, dx) * (180 / Math.PI);
				angle = (angle + 90 + 360) % 360; // Rotate so 0¬∞ is at top
				return Math.round(angle);
			}
			
			function setupHandleDrag(handle, isStartHandle) {
				let isDragging = false;
				
				handle.addEventListener('mousedown', function(e) {
					e.stopPropagation();
					e.preventDefault();
					isDragging = true;
					document.addEventListener('mousemove', onMouseMove);
					document.addEventListener('mouseup', onMouseUp);
				});
				
				handle.addEventListener('touchstart', function(e) {
					e.stopPropagation();
					e.preventDefault();
					isDragging = true;
					document.addEventListener('touchmove', onTouchMove);
					document.addEventListener('touchend', onTouchEnd);
				});
				
				function onMouseMove(e) {
					if (!isDragging) return;
					
					const rect = circle.getBoundingClientRect();
					const x = e.clientX - rect.left;
					const y = e.clientY - rect.top;
					
					const angle = getAngleFromPosition(x, y);
					
					if (isStartHandle) {
						startInput.value = angle;
					} else {
						endInput.value = angle;
					}
					
					updateFromInputs();
				}
				
				function onTouchMove(e) {
					if (!isDragging || !e.touches[0]) return;
					
					const rect = circle.getBoundingClientRect();
					const x = e.touches[0].clientX - rect.left;
					const y = e.touches[0].clientY - rect.top;
					
					const angle = getAngleFromPosition(x, y);
					
					if (isStartHandle) {
						startInput.value = angle;
					} else {
						endInput.value = angle;
					}
					
					updateFromInputs();
				}
				
				function onMouseUp() {
					isDragging = false;
					document.removeEventListener('mousemove', onMouseMove);
					document.removeEventListener('mouseup', onMouseUp);
				}
				
				function onTouchEnd() {
					isDragging = false;
					document.removeEventListener('touchmove', onTouchMove);
					document.removeEventListener('touchend', onTouchEnd);
				}
			}
			
			// Initialize the base gradient (this should NOT change when handles move)
			function initBaseGradient() {
				// This creates a FIXED gradient that doesn't shift
				circle.style.background = `
					conic-gradient(
						from 180deg,
						#ff0000 0deg,
						#ffff00 90deg,
						#00ff00 180deg,
						#0000ff 270deg,
						#ff0000 360deg
					)
				`;
			}
			
			// Initialize everything
			initBaseGradient();
			updateFromInputs();
			
			// Setup drag for handles
			setupHandleDrag(startHandle, true);
			setupHandleDrag(endHandle, false);
			
			// Update on input changes
			startInput.addEventListener('change', updateFromInputs);
			endInput.addEventListener('change', updateFromInputs);
			startInput.addEventListener('input', updateFromInputs);
			endInput.addEventListener('input', updateFromInputs);
			
			// Add keyboard controls
			startInput.addEventListener('keydown', function(e) {
				if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
					e.preventDefault();
					const step = e.key === 'ArrowUp' ? 1 : -1;
					startInput.value = ((parseFloat(startInput.value) || 0) + step + 360) % 360;
					updateFromInputs();
				}
			});
			
			endInput.addEventListener('keydown', function(e) {
				if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
					e.preventDefault();
					const step = e.key === 'ArrowUp' ? 1 : -1;
					endInput.value = ((parseFloat(endInput.value) || 0) + step + 360) % 360;
					updateFromInputs();
				}
			});
		}

	// Helper function to update aspect circle handles
	function updateAspectCircleHandles(startAngle, endAngle) {
		const startHandle = document.getElementById('aspect-handle-start');
		const endHandle = document.getElementById('aspect-handle-end');
		const selectedOverlay = document.getElementById('aspect-selected-overlay');
		const circle = document.getElementById('aspect-circle');
		
		if (!startHandle || !endHandle || !selectedOverlay || !circle) return;
		
		const radius = 100;
		const centerX = 100;
		const centerY = 100;
		
		// Update handle positions
		function updateHandlePosition(handle, angle) {
			const radians = (angle - 90) * (Math.PI / 180);
			const x = centerX + radius * Math.cos(radians);
			const y = centerY + radius * Math.sin(radians);
			handle.style.left = x + 'px';
			handle.style.top = y + 'px';
		}
		
		updateHandlePosition(startHandle, startAngle);
		updateHandlePosition(endHandle, endAngle);
		
		// Update selected range visualization
		let gradientStops = '';
		
		if (endAngle > startAngle) {
			// Normal range (no wrap)
			gradientStops = `
				transparent 0deg,
				transparent ${startAngle}deg,
				rgba(139, 69, 19, 0.3) ${startAngle}deg,
				rgba(139, 69, 19, 0.3) ${endAngle}deg,
				transparent ${endAngle}deg,
				transparent 360deg
			`;
		} else {
			// Wrapped range (e.g., 300¬∞ to 60¬∞)
			gradientStops = `
				rgba(139, 69, 19, 0.3) 0deg,
				rgba(139, 69, 19, 0.3) ${endAngle}deg,
				transparent ${endAngle}deg,
				transparent ${startAngle}deg,
				rgba(139, 69, 19, 0.3) ${startAngle}deg,
				rgba(139, 69, 19, 0.3) 360deg
			`;
		}
		
		selectedOverlay.style.background = `conic-gradient(${gradientStops})`;
		selectedOverlay.style.border = '2px solid #8B4513';
		selectedOverlay.style.boxSizing = 'border-box';
		
		// Update global aspect range
		aspectRange = [startAngle, endAngle];
	}

		function updateAllSliderBackgrounds() {
			if (window.elevationSlider) updateSliderBackground(window.elevationSlider, 
				currentView === 'elevation' ? 'elevation' : 'default');
			if (window.tempSlider) updateSliderBackground(window.tempSlider, 
				currentView === 'temp' ? 'temp' : 'default');
			if (window.moistureSlider) updateSliderBackground(window.moistureSlider, 
				currentView === 'moisture' ? 'moisture' : 'default');
			if (window.slopeSlider) updateSliderBackground(window.slopeSlider, 
				currentView === 'slope' ? 'slope' : 'default');
			// Note: aspect slider doesn't use updateSliderBackground as it's circular
			if (window.monthSlider) updateSliderBackground(window.monthSlider, 
				currentView === 'month' ? 'month' : 'default');
		}
        
		function updateSliderBackground(slider, viewType) {
			const sliderElement = slider.target;
			const baseElement = sliderElement.querySelector('.noUi-base');
			
			if (!baseElement) return;
			
			switch(viewType) {
				case 'elevation':
					baseElement.style.background = 'linear-gradient(to right, #6A0DAD, #0000FF, #00FF00, #FFA500, #FFA500, #FF0000)';
					break;
				case 'temp':
					baseElement.style.background = 'linear-gradient(to right, #0000FF, #FF0000)';
					break;
				case 'moisture':
					baseElement.style.background = 'linear-gradient(to right, #FFD700, #00008B)';
					break;
				case 'slope':
					baseElement.style.background = 'linear-gradient(to right, #00FF00, #FF0000)';
					break;
				case 'aspect':
					baseElement.style.background = 'linear-gradient(to right, #FF0000, #FFFF00, #00FF00, #0000FF, #FF0000)';
					break;
				case 'month':
					// Create gradient that cycles through 12 months across 365 days
					const monthColors = [
						'#FF6B6B', '#FF8E53', '#FFB347', '#FFD166', // Jan-Apr
						'#A8E6CF', '#7BC8A4', '#4ECDC4', '#45B7D1', // May-Aug
						'#6C5CE7', '#A29BFE', '#DDA0DD', '#FFB6C1'  // Sep-Dec
					];
					
					// Create 12 color stops for the 12 months
					let gradientStops = '';
					for (let i = 0; i < 12; i++) {
						const position = (i / 12) * 100;
						gradientStops += `${monthColors[i]} ${position}%, `;
					}
					// Add the last color again at 100%
					gradientStops += `${monthColors[0]} 100%`;
					
					baseElement.style.background = `linear-gradient(to right, ${gradientStops})`;
					break;
				default:
					baseElement.style.background = '#f0f0f0';
			}
		}

        // Create range slider with two handles
		function createRangeSlider(id, min, max, values, step) {
			const slider = noUiSlider.create(document.getElementById(id), {
				start: values,
				connect: true,
				step: step,
				range: {
					'min': min,
					'max': max
				},
				behaviour: 'drag',
				tooltips: true,
				format: {
					to: function(value) {
						// Ensure value is a number before calling toFixed
						const numValue = typeof value === 'string' ? parseFloat(value) : value;
						return step < 1 ? numValue.toFixed(2) : Math.round(numValue);
					},
					from: function(value) {
						return Number(value);
					}
				}
			});
			return slider;
		}
        
		function updateMonthLabels() {
			const minDayElem = document.getElementById('month-min');
			const maxDayElem = document.getElementById('month-max');
			
			if (minDayElem && maxDayElem) {
				// Convert day number to month/day format
				const getMonthDay = (dayNum) => {
					// Days per month (non-leap year)
					const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
					const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
									   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
					
					let dayCount = dayNum;
					let month = 0;
					
					// Find which month this day falls in
					while (dayCount > daysInMonth[month]) {
						dayCount -= daysInMonth[month];
						month++;
						if (month >= 12) {
							month = 11; // Shouldn't happen with 1-365 range
							dayCount = daysInMonth[11];
							break;
						}
					}
					
					return `${monthNames[month]} ${Math.round(dayCount)}`;
				};
				
				minDayElem.textContent = getMonthDay(monthRange[0]);
				maxDayElem.textContent = getMonthDay(monthRange[1]);
			}
		}
        
		function updateMapPoints() {			
			// Clear existing points
			mapPoints.forEach(point => map.removeLayer(point));
			mapPoints = [];
			
			if (!currentView) {
				currentView = 'default';
			}
			
			// Show/hide sliders based on current view
			const elevationSlider = document.getElementById('elevation-slider');
			const tempSlider = document.getElementById('temp-slider');
			const moistureSlider = document.getElementById('moisture-slider');
			const slopeSlider = document.getElementById('slope-slider');
			const aspectSlider = document.getElementById('aspect-slider');
			const monthSlider = document.getElementById('month-slider');

			const userMarkerRadius = userPointSize;
			const highlightedRadius = highlightPointSize;

			if (elevationSlider) elevationSlider.classList.toggle('active', currentView === 'elevation');
			if (tempSlider) tempSlider.classList.toggle('active', currentView === 'temp');
			if (moistureSlider) moistureSlider.classList.toggle('active', currentView === 'moisture');
			if (slopeSlider) slopeSlider.classList.toggle('active', currentView === 'slope');
			if (aspectSlider) aspectSlider.classList.toggle('active', currentView === 'aspect');
			if (monthSlider) monthSlider.classList.toggle('active', currentView === 'month');

			// Get current slider values when switching views
			if (currentView === 'elevation' && window.elevationSlider) {
				const values = window.elevationSlider.get();
				elevationRange = values.map(v => parseFloat(v));
			} else if (currentView === 'temp' && window.tempSlider) {
				const values = window.tempSlider.get();
				tempRange = values.map(v => parseFloat(v));
			} else if (currentView === 'moisture' && window.moistureSlider) {
				const values = window.moistureSlider.get();
				moistureRange = values.map(v => parseFloat(v));
			} else if (currentView === 'slope' && window.slopeSlider) {
				const values = window.slopeSlider.get();
				slopeRange = values.map(v => parseFloat(v));
			} else if (currentView === 'month' && window.monthSlider) {
				const values = window.monthSlider.get();
				monthRange = values.map(v => Math.round(parseFloat(v)));
				updateMonthLabels();
			}
			
			// If not in a filtered view, use default ranges
			if (currentView !== 'elevation') elevationRange = [0, 12000];
			if (currentView !== 'temp') tempRange = [30, 70];
			if (currentView !== 'moisture') moistureRange = [0, 0.5];
			if (currentView !== 'month') monthRange = [1, 12];
			
			// Plot points from all active datasets
			chartData.forEach(point => {
				// Filter based on ranges
				const inElevationRange = point.elevationFt >= elevationRange[0] && 
									  point.elevationFt <= elevationRange[1];
				const inTempRange = point.soilTemp !== null && 
								 point.soilTemp >= tempRange[0] && 
								 point.soilTemp <= tempRange[1];
				const inMoistureRange = point.soilMoisture !== null && 
									 point.soilMoisture >= moistureRange[0] && 
									 point.soilMoisture <= moistureRange[1];
				const inSlopeRange = point.slopeDeg !== null && 
								  point.slopeDeg !== undefined &&
								  point.slopeDeg >= slopeRange[0] && 
								  point.slopeDeg <= slopeRange[1];
				let inAspectRange = true;

				if (currentView === 'aspect') {
					const aspect = point.slopeAspectDeg;
					if (aspect !== null && aspect !== undefined) {
						const [start, end] = aspectRange;
						
						// Handle the wrap-around case
						if (end >= start) {
							// Normal range (e.g., 0¬∞ to 180¬∞)
							inAspectRange = aspect >= start && aspect <= end;
						} else {
							// Wrapped range (e.g., 300¬∞ to 60¬∞)
							inAspectRange = aspect >= start || aspect <= end;
						}
					} else {
						inAspectRange = false; // No aspect data
					}
				}

				let inMonthRange = true;
				if (currentView === 'month') {
					inMonthRange = isPointInDayRange(point, monthRange[0], monthRange[1]);
				}

				if (!inElevationRange || !inTempRange || !inMoistureRange || !inSlopeRange || !inAspectRange || !inMonthRange) return;
				
				// Get alpha/opacity from activeDatasets
				const datasetInfo = activeDatasets[point.datasetId];
				let opacity = 0.8; // default
				
				if (datasetInfo) {
					// Extract alpha from color string (if present)
					const color = datasetInfo.color;
					if (color.length === 9) { // #RRGGBBAA format
						const alphaHex = color.substring(7, 9);
						opacity = parseInt(alphaHex, 16) / 255;
					}
				}

				// Get point size based on dataset
				let pointRadius = pointSize; // Default
				if (point.datasetId && activeDatasets[point.datasetId]) {
					pointRadius = activeDatasets[point.datasetId].pointSize || pointSize;
				}
				
				// Set color based on current view
				let color, fillColor;
				
				switch(currentView) {
					case 'elevation':
						color = elevationColorScale(point.elevationFt);
						fillColor = color;
						break;
					case 'temp':
						color = tempColorScale(point.soilTemp);
						fillColor = color;
						break;
					case 'moisture':
						color = moistureColorScale(point.soilMoisture);
						fillColor = color;
						break;
					case 'slope':
						color = slopeColorScale(point.slopeDeg);
						fillColor = color;
						break;
					case 'aspect':
						if (point.slopeAspectDeg !== null && point.slopeAspectDeg !== undefined) {
							// Normalize aspect to 0-360
							const normalizedAspect = ((point.slopeAspectDeg % 360) + 360) % 360;
							const shiftedAspect = (normalizedAspect + 180) % 360;
							color = aspectColorScale(shiftedAspect);
							fillColor = color;
						} else {
							// No aspect data - use gray
							color = '#cccccc';
							fillColor = color;
						}
						break;
					case 'month':
						// Calculate day of year (1-365) from month and day
						const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
						let dayOfYear = 0;
						
						// Sum days from previous months
						for (let m = 0; m < point.month - 1; m++) {
							dayOfYear += daysInMonth[m];
						}
						
						// Add days in current month
						dayOfYear += point.monthDay;
						
						// Clamp to 1-365 range
						dayOfYear = Math.max(1, Math.min(365, dayOfYear));
						
						// Get position in year (0-1)
						const yearFraction = (dayOfYear - 1) / 364;
						
						// Get color from month gradient based on position
						const monthGradientColors = [
							'#FF6B6B', '#FF8E53', '#FFB347', '#FFD166', // Jan-Apr
							'#A8E6CF', '#7BC8A4', '#4ECDC4', '#45B7D1', // May-Aug
							'#6C5CE7', '#A29BFE', '#DDA0DD', '#FFB6C1'  // Sep-Dec
						];
						
						// Interpolate between month colors
						const gradientPos = yearFraction * 11; // 0-11 for 12 colors
						const colorIndex = Math.floor(gradientPos);
						const colorFraction = gradientPos - colorIndex;
						
						if (colorIndex < 11) {
							// Interpolate between two colors
							const startColor = monthGradientColors[colorIndex];
							const endColor = monthGradientColors[colorIndex + 1];
							color = interpolateColor(startColor, endColor, colorFraction);
						} else {
							color = monthGradientColors[11];
						}
						
						fillColor = color;
						break;
					default:
						// Use dataset color in default view
						color = datasetInfo ? datasetInfo.color : point.datasetColor;
						fillColor = color;
				}
				
				// Check if this is the currently highlighted point
				const isHighlighted = highlightedPoint && 
									  highlightedPoint.latitude === point.latitude && 
									  highlightedPoint.longitude === point.longitude;
				
				if (isHighlighted) {
					// Highlighted point - use highlight color with full opacity
					const marker = L.circleMarker([point.latitude, point.longitude], {
						radius: highlightPointSize, // Use highlight point size
						color: highlightColor,
						fillColor: highlightColor,
						fillOpacity: 0.9,
						weight: 3
					}).addTo(map);
					
					marker.on('click', () => {
						highlightPoint(point);
						showPointInfo(point);
					});
					mapPoints.push(marker);
				} else {
					// Regular point - use calculated color and opacity
					const marker = L.circleMarker([point.latitude, point.longitude], {
						radius: pointRadius, // Use calculated point size
						color: fillColor,
						fillColor: fillColor,
						fillOpacity: opacity, // Use the calculated opacity
						opacity: opacity,
						weight: point.datasetId === 'user_data' ? 2 : 0
					}).addTo(map);
					
					// Store dataset info for reference
					marker._datasetId = point.datasetId;
					
					marker.on('click', () => {
						highlightPoint(point);
						showPointInfo(point);
					});
					mapPoints.push(marker);
				}
			});
			
			// Plot user-added points
			if (userData.length > 0) {
				userData.forEach(point => {
					// Filter based on ranges
					const inElevationRange = point.elevationFt >= elevationRange[0] && 
										  point.elevationFt <= elevationRange[1];
					const inTempRange = point.soilTemp !== null && 
									 point.soilTemp >= tempRange[0] && 
									 point.soilTemp <= tempRange[1];
					const inMoistureRange = point.soilMoisture !== null && 
										 point.soilMoisture >= moistureRange[0] && 
										 point.soilMoisture <= moistureRange[1];
					let inMonthRange = true; // Default to true for non-month views
					if (currentView === 'month') {
						inMonthRange = isPointInDayRange(point, monthRange[0], monthRange[1]);
					}
					
					if (!inElevationRange || !inTempRange || !inMoistureRange || !inMonthRange) return;
					
					if (point.datasetId === 'user_data') {
						// User points
						const isHighlighted = highlightedPoint && 
											  highlightedPoint.latitude === point.latitude && 
											  highlightedPoint.longitude === point.longitude;
						
						if (isHighlighted) {
							// Highlighted user point
							const marker = L.circleMarker([point.latitude, point.longitude], {
								radius: highlightPointSize, // Use highlight point size
								color: userPointColor,
								fillColor: userPointColor,
								fillOpacity: 0.9,
								weight: 3
							}).addTo(map);
							
							marker._datasetId = 'user_data';
							marker._isHighlighted = true;
							
							marker.on('click', (e) => {
								L.DomEvent.stopPropagation(e);
								highlightPoint(point);
								showPointInfo(point);
							});
							
							mapPoints.push(marker);
						} else {
							// Regular user point
							const marker = L.circleMarker([point.latitude, point.longitude], {
								radius: userPointSize, // Use user point size
								color: userPointColor,
								fillColor: userPointColor,
								fillOpacity: 0.8,
								weight: 2,
								className: 'user-point-marker'
							}).addTo(map);
							
							marker._datasetId = 'user_data';
							marker._isHighlighted = false;
							
							marker.on('click', (e) => {
								L.DomEvent.stopPropagation(e);
								highlightPoint(point);
								showPointInfo(point);
							});
							
							mapPoints.push(marker);
						}
					}
				});
			}
		}

		function aspectToCompass(degrees) {
			const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 
							   'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
			const index = Math.round((degrees % 360) / 22.5);
			return directions[index % 16];
		}

		function isPointInDayRange(point, startDay, endDay) {
			// Convert point's month/day to day of year
			const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
			let pointDayOfYear = 0;
			
			// Sum days from previous months
			for (let m = 0; m < point.month - 1; m++) {
				pointDayOfYear += daysInMonth[m];
			}
			
			// Add days in current month
			pointDayOfYear += point.monthDay;
			
			// Clamp to valid range
			pointDayOfYear = Math.max(1, Math.min(365, pointDayOfYear));
			
			// Check if point is within the day range
			return pointDayOfYear >= startDay && pointDayOfYear <= endDay;
		}

		function interpolateColor(color1, color2, factor) {
			// Convert hex to RGB
			const hexToRgb = (hex) => {
				const r = parseInt(hex.slice(1, 3), 16);
				const g = parseInt(hex.slice(3, 5), 16);
				const b = parseInt(hex.slice(5, 7), 16);
				return {r, g, b};
			};
			
			// RGB to hex
			const rgbToHex = (r, g, b) => {
				return '#' + [r, g, b].map(x => {
					const hex = Math.round(x).toString(16);
					return hex.length === 1 ? '0' + hex : hex;
				}).join('');
			};
			
			const rgb1 = hexToRgb(color1);
			const rgb2 = hexToRgb(color2);
			
			const r = rgb1.r + factor * (rgb2.r - rgb1.r);
			const g = rgb1.g + factor * (rgb2.g - rgb1.g);
			const b = rgb1.b + factor * (rgb2.b - rgb1.b);
			
			return rgbToHex(r, g, b);
		}
        
        function toggleFullscreen() {
            const mapContainer = document.querySelector('.map-container');
            
            if (!document.fullscreenElement) {
                mapContainer.classList.add('fullscreen');
                if (mapContainer.requestFullscreen) {
                    mapContainer.requestFullscreen();
                }
                map.invalidateSize();
            } else {
                exitFullscreen();
            }
        }

        function exitFullscreen() {
            const mapContainer = document.querySelector('.map-container');
            
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            mapContainer.classList.remove('fullscreen');
            map.invalidateSize();
        }

        document.addEventListener('fullscreenchange', function() {
            const mapContainer = document.querySelector('.map-container');
            
            if (!document.fullscreenElement && mapContainer.classList.contains('fullscreen')) {
                mapContainer.classList.remove('fullscreen');
                map.invalidateSize();
            }
        });

        document.addEventListener('webkitfullscreenchange', function() {
            const mapContainer = document.querySelector('.map-container');
            
            if (!document.webkitFullscreenElement && mapContainer.classList.contains('fullscreen')) {
                mapContainer.classList.remove('fullscreen');
                map.invalidateSize();
            }
        });

        document.addEventListener('mozfullscreenchange', function() {
            const mapContainer = document.querySelector('.map-container');
            
            if (!document.mozFullScreenElement && mapContainer.classList.contains('fullscreen')) {
                mapContainer.classList.remove('fullscreen');
                map.invalidateSize();
            }
        });

        document.addEventListener('MSFullscreenChange', function() {
            const mapContainer = document.querySelector('.map-container');
            
            if (!document.msFullscreenElement && mapContainer.classList.contains('fullscreen')) {
                mapContainer.classList.remove('fullscreen');
                map.invalidateSize();
            }
        });
        
        // Initialize charts
		function initCharts() {
			const mainCtx = document.getElementById('mainChart').getContext('2d');
			const histogramCtx = document.getElementById('histogramChart').getContext('2d');
			
			// Main chart configuration
			mainChart = new Chart(mainCtx, {
				type: 'scatter',
				data: {
					datasets: []
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					elements: {
						point: {
							radius: 1,
							hoverRadius: 3,
							hitRadius: 3
						}
					},
					onClick: (evt, elements) => {
						if (elements.length > 0) {
							const element = elements[0];
							const datasetIndex = element.datasetIndex;
							const index = element.index;
							
							// Get the chart instance
							const chart = evt.chart;
							const dataset = chart.data.datasets[datasetIndex];
							
							if (dataset && dataset.data[index]) {
								// Get the original data point (not just x/y properties)
								const dataPoint = dataset.data[index];
								
								// Find the corresponding point in allData using the original properties
								// Look for a point with matching coordinates and date
								const originalPoint = allData.find(p => 
									p.latitude === dataPoint.latitude && 
									p.longitude === dataPoint.longitude &&
									p.date === dataPoint.date
								);
								
								if (originalPoint) {
									highlightPoint(originalPoint);
									showPointInfo(originalPoint);
								}
							}
						}
					},
					plugins: {
						legend: {
							display: true,
							position: 'top',
							align: 'center',
							labels: {
								boxWidth: 12,
								padding: 15,
								font: {
									size: 12,
									family: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif"
								},
								usePointStyle: true,
								pointStyle: 'circle',
								color: '#333'
							}
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									const dataPoint = context.dataset.data[context.dataIndex];
									const tooltipLines = [
										`Dataset: ${dataPoint.datasetName || 'User Data'}`,
										`Date: ${dataPoint.date || 'N/A'}`,
										`Elevation: ${dataPoint.elevationFt} ft`,
										`Soil Temp: ${dataPoint.soilTemp ? dataPoint.soilTemp.toFixed(1) : 'N/A'} ¬∞F`,
										`Soil Moisture: ${dataPoint.soilMoisture ? dataPoint.soilMoisture.toFixed(3) : 'N/A'}`
									];
									
									// Add slope if available
									if (dataPoint.slopeDeg !== null && dataPoint.slopeDeg !== undefined) {
										tooltipLines.push(`Slope: ${dataPoint.slopeDeg.toFixed(1)}¬∞`);
									}
									
									// Add aspect if available (with compass direction)
									if (dataPoint.slopeAspectDeg !== null && dataPoint.slopeAspectDeg !== undefined) {
										const compassDir = aspectToCompass(dataPoint.slopeAspectDeg);
										tooltipLines.push(`Aspect: ${dataPoint.slopeAspectDeg.toFixed(1)}¬∞ (${compassDir})`);
									}
									
									return tooltipLines;
								}
							}
						}
					},
					scales: {
						x: {
							title: {
								display: true,
								text: 'X-Axis',
								font: {
									weight: 'bold'
								}
							},
							grid: {
								color: 'rgba(0, 0, 0, 0.05)'
							}
						},
						y: {
							title: {
								display: true,
								text: 'Y-Axis',
								font: {
									weight: 'bold'
								}
							},
							grid: {
								color: 'rgba(0, 0, 0, 0.05)'
							}
						}
					}
				}
			});
			
			// Histogram chart configuration
			histogramChart = new Chart(histogramCtx, {
				type: 'bar',
				data: {
					labels: [],
					datasets: []
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					onClick: (evt, elements) => {
						if (elements.length > 0) {
							const element = elements[0];
							const chart = evt.chart;
							const dimension = document.getElementById('histogram-dimension').value;
							
							// Get the bin label
							const label = chart.data.labels[element.index];
							
							// For slope and aspect, ensure we have the full range
							if (dimension === 'slopeDeg' || dimension === 'slopeAspectDeg') {
								// Get the tooltip for better context
								const tooltip = chart.tooltip;
								if (tooltip && tooltip.dataPoints && tooltip.dataPoints.length > 0) {
									// Try to get the title from tooltip
									if (tooltip.title && tooltip.title.length > 0) {
										switchToMapViewFromHistogram(dimension, tooltip.title[0]);
									} else {
										// Use the label
										switchToMapViewFromHistogram(dimension, label);
									}
								} else {
									// Fallback
									switchToMapViewFromHistogram(dimension, label);
								}
							} else {
								// Original logic for other dimensions
								const tooltip = chart.tooltip;
								if (tooltip && tooltip.dataPoints && tooltip.dataPoints.length > 0) {
									const tooltipTitle = tooltip.title && tooltip.title.length > 0 
										? tooltip.title[0] 
										: null;
									
									if (tooltipTitle) {
										switchToMapViewFromHistogram(dimension, tooltipTitle);
									} else {
										switchToMapViewFromHistogram(dimension, label);
									}
								} else {
									switchToMapViewFromHistogram(dimension, label);
								}
							}
						}
					},
					plugins: {
						legend: {
							display: true,
							position: 'top'
						},
						tooltip: {
							mode: 'index',
							intersect: false,
							callbacks: {
								label: function(context) {
									const label = context.dataset.label || '';
									const value = context.parsed.y;
									const total = context.chart.data.datasets
										.map(ds => ds.data[context.dataIndex])
										.reduce((a, b) => a + b, 0);
									const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
									return `${label}: ${value} (${percentage}%)`;
								}
							}
						}
					},
					scales: {
						x: {
							stacked: true,
							title: {
								display: true,
								text: 'Value',
								font: {
									weight: 'bold'
								}
							},
							grid: {
								display: false
							}
						},
						y: {
							stacked: true,
							title: {
								display: true,
								text: 'Observations',
								font: {
									weight: 'bold'
								}
							},
							beginAtZero: true,
							grid: {
								color: 'rgba(0, 0, 0, 0.05)'
							}
						}
					}
				}
			});
			
			// Set up chart type change listener
			document.getElementById('x-axis').addEventListener('change', updateMainChart);
			document.getElementById('y-axis').addEventListener('change', updateMainChart);
			
			// Set up histogram dimension change listener
			document.getElementById('histogram-dimension').addEventListener('change', updateHistogram);
			document.getElementById('bin-count').addEventListener('change', updateHistogram);
			document.getElementById('bin-offset').addEventListener('change', updateHistogram);
			
			// Set initial state
			setDefaultAxes();
		}

		function switchToMapViewFromHistogram(dimension, label) {
			// Map histogram dimensions to map views
			const dimensionToView = {
				'elevationFt': 'elevation',
				'soilTemp': 'temp',
				'soilMoisture': 'moisture',
				'slopeDeg': 'slope',
				'slopeAspectDeg': 'aspect',
				'month': 'month',
				'yearMonth': 'month'
			};
			
			const view = dimensionToView[dimension];
			if (!view) return;
			
			// Activate the corresponding view button
			const viewButtons = document.querySelectorAll('.view-options button');
			viewButtons.forEach(btn => {
				btn.classList.remove('active');
				if (btn.dataset.view === view) {
					btn.classList.add('active');
				}
			});
			
			// Set current view
			currentView = view;

			// Update all slider backgrounds for the new view
			updateAllSliderBackgrounds();
			
			// Parse the label to get range values
			let rangeValues = parseLabelToRange(dimension, label);
			
			if (rangeValues) {
				// Update the corresponding slider
				updateSliderFromRange(dimension, rangeValues);
			}
			
			// Update map points with new view
			updateMapPoints();
			
			// Scroll to map if enabled
			if (enableScroll) {
				document.getElementById('map').scrollIntoView({ behavior: 'smooth' });
			}
		}

		function parseLabelToRange(dimension, label) {
			// Parse histogram bin label to extract range values
			// Example labels: "1000 - 2000 ft", "Jan", "45 - 50 ¬∞F", "0.10 - 0.15"
			
			if (dimension === 'month') {
				// The label parameter contains the tooltip title, which is "Month - Week X"
				// Parse it to get month and week
				const match = label.match(/^(\w{3})\s*-\s*Week\s*(\d+)$/i);
				
				if (match) {
					const monthName = match[1];
					const weekNumber = parseInt(match[2]);
					
					const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
									   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
					const monthIndex = monthNames.indexOf(monthName);
					
					if (monthIndex !== -1 && weekNumber >= 1 && weekNumber <= 5) {
						// Convert month and week to day range
						const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
						let startDay = 1;
						
						// Sum days from previous months
						for (let m = 0; m < monthIndex; m++) {
							startDay += daysInMonth[m];
						}
						
						// Add days from previous weeks in this month
						startDay += (weekNumber - 1) * 7;
						
						// End day is start day + 6 (or end of month)
						const daysInThisMonth = daysInMonth[monthIndex];
						const remainingDays = daysInThisMonth - ((weekNumber - 1) * 7);
						const weekDays = Math.min(7, remainingDays);
						const endDay = startDay + weekDays - 1;
						
						return [startDay, endDay];
					}
				}
				
				// Fallback: If we can't parse week info, use the whole month
				const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
								   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
				const monthIndex = monthNames.indexOf(label);
				
				if (monthIndex !== -1) {
					// When clicking on a month label, show the full month
					const daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
					let startDay = 1;
					
					// Sum days from previous months
					for (let m = 0; m < monthIndex; m++) {
						startDay += daysInMonth[m];
					}
					
					const endDay = startDay + daysInMonth[monthIndex] - 1;
					return [startDay, endDay];
				}
			} else if (dimension === 'yearMonth') {
				// Handle year-month labels like "2023-01"
				const [year, month] = label.split('-').map(Number);
				if (month) {
					return [month, month]; // Single month range
				}
			} else if (dimension === 'slopeDeg' || dimension === 'slopeAspectDeg') {
				// Handle slope and aspect dimensions
				// Labels might be: "0 - 10", "10 - 20", "30 - 40 degrees", etc.
				
				// Remove any units or extra text
				const cleanLabel = label.replace(/degrees|¬∞|deg/gi, '').trim();
				
				// Try to extract numeric range
				const rangeMatch = cleanLabel.match(/([\d\.]+)\s*-\s*([\d\.]+)/);
				if (rangeMatch) {
					let min = parseFloat(rangeMatch[1]);
					let max = parseFloat(rangeMatch[2]);
					
					// For aspect, ensure values are within 0-360
					if (dimension === 'slopeAspectDeg') {
						min = ((min % 360) + 360) % 360;
						max = ((max % 360) + 360) % 360;
						
						// For aspect, we might want to handle the circular nature
						// For simplicity, just return the range as is
						// The map filtering logic will handle wrap-around
					}
					
					return [min, max];
				}
				
				// If no range found, try to parse single value
				const singleMatch = cleanLabel.match(/^([\d\.]+)$/);
				if (singleMatch) {
					let value = parseFloat(singleMatch[1]);
					
					if (dimension === 'slopeAspectDeg') {
						value = ((value % 360) + 360) % 360;
					}
					
					// Create a small range around the single value
					if (dimension === 'slopeDeg') {
						return [Math.max(0, value - 5), Math.min(90, value + 5)];
					} else {
						// For aspect, create a 20-degree range
						const range = 10;
						return [
							((value - range) % 360 + 360) % 360,
							((value + range) % 360 + 360) % 360
						];
					}
				}
			} else {
				// Handle numeric ranges for other dimensions
				const rangeMatch = label.match(/([\d\.]+)\s*-\s*([\d\.]+)/);
				if (rangeMatch) {
					let min = parseFloat(rangeMatch[1]);
					let max = parseFloat(rangeMatch[2]);
					
					// Adjust for ft vs elevation values
					if (dimension === 'elevationFt' && label.includes('ft')) {
						// Already in correct units
					}
					
					return [min, max];
				}
			}
			
			return null;
		}

		function updateSliderFromRange(dimension, rangeValues) {
			const [minValue, maxValue] = rangeValues;
			
			// Show the corresponding slider container
			const sliderContainers = {
				'elevationFt': 'elevation-slider',
				'soilTemp': 'temp-slider',
				'soilMoisture': 'moisture-slider',
				'slopeDeg': 'slope-slider',
				'slopeAspectDeg': 'aspect-slider',
				'month': 'month-slider',
				'yearMonth': 'month-slider'
			};
			
			const sliderId = sliderContainers[dimension];
			if (!sliderId) return;
			
			// Activate the slider container
			const allSliders = ['elevation-slider', 'temp-slider', 'moisture-slider', 
							   'slope-slider', 'aspect-slider', 'month-slider']; // UPDATED
			allSliders.forEach(id => {
				const el = document.getElementById(id);
				if (el) el.classList.remove('active');
			});
			
			const targetSlider = document.getElementById(sliderId);
			if (targetSlider) {
				targetSlider.classList.add('active');
			}
			
			// Update the slider values
			switch(dimension) {
				case 'elevationFt':
					if (window.elevationSlider) {
						window.elevationSlider.set([minValue, maxValue]);
						elevationRange = [minValue, maxValue];
					}
					break;
				case 'soilTemp':
					if (window.tempSlider) {
						window.tempSlider.set([minValue, maxValue]);
						tempRange = [minValue, maxValue];
					}
					break;
				case 'soilMoisture':
					if (window.moistureSlider) {
						window.moistureSlider.set([minValue, maxValue]);
						moistureRange = [minValue, maxValue];
					}
					break;
				case 'slopeDeg':
					if (window.slopeSlider) {
						// Ensure values are within 0-90
						const clampedMin = Math.max(0, Math.min(90, minValue));
						const clampedMax = Math.max(0, Math.min(90, maxValue));
						window.slopeSlider.set([clampedMin, clampedMax]);
						slopeRange = [clampedMin, clampedMax];
					}
					break;
				case 'slopeAspectDeg':
					// For the circular aspect slider, update the input fields
					const startInput = document.getElementById('aspect-start');
					const endInput = document.getElementById('aspect-end');
					
					if (startInput && endInput) {
						// Normalize to 0-360
						const normalizedMin = ((minValue % 360) + 360) % 360;
						const normalizedMax = ((maxValue % 360) + 360) % 360;
						
						startInput.value = Math.round(normalizedMin);
						endInput.value = Math.round(normalizedMax);
						
						// Update the handles manually
						updateAspectCircleHandles(normalizedMin, normalizedMax);
					}
					break;
				case 'month':
				case 'yearMonth':
					if (window.monthSlider) {
						window.monthSlider.set([minValue, maxValue]);
						monthRange = [minValue, maxValue];
						updateMonthLabels();
					}
					break;
			}
		}

		// Set default axis selections
		function setDefaultAxes() {
			document.getElementById('x-axis').value = 'monthFraction';
			document.getElementById('y-axis').value = 'elevationFt';
			updateMainChart();
		}

		// Update main chart based on selections
		function updateMainChart() {
			const xProp = document.getElementById('x-axis').value;
			const yProp = document.getElementById('y-axis').value;
			
			// Update axis labels based on selection
			const axisLabels = {
				'soilTemp': 'Soil Temperature (¬∞F)',
				'soilMoisture': 'Soil Moisture',
				'monthFraction': 'Month',
				'elevationFt': 'Elevation (ft)',
				'slopeDeg': 'Slope (degrees)',
				'slopeAspectDeg': 'Aspect (degrees)'
			};
			
			mainChart.options.scales.x.title.text = axisLabels[xProp] || 'X-Axis';
			mainChart.options.scales.y.title.text = axisLabels[yProp] || 'Y-Axis';
			
			// Special handling for month axis
			if (xProp === 'monthFraction') {
				mainChart.options.scales.x.ticks = {
					callback: function(value) {
						const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
									  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
						const monthIndex = Math.floor(value) - 1;
						if (monthIndex >= 0 && monthIndex < 12) {
							return months[monthIndex];
						}
						return '';
					},
					labelOffset: 20,
					stepSize: 1,
					autoSkip: false,
					maxRotation: 45,
					minRotation: 0,
					padding: 5
				};
				mainChart.options.scales.x.min = 1;
				mainChart.options.scales.x.max = 13;
			} else if (xProp === 'elevationFt') {
				// Set elevation max to 12000
				mainChart.options.scales.x.max = 12000;
				mainChart.options.scales.x.ticks = {
					stepSize: 1000
				};
				mainChart.options.scales.x.min = 0;
			} else {
				mainChart.options.scales.x.ticks = {};
				mainChart.options.scales.x.min = undefined;
				mainChart.options.scales.x.max = undefined;
			}

			if (yProp === 'monthFraction') {
				mainChart.options.scales.y.ticks = {
					callback: function(value) {
						const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
									  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
						const monthIndex = Math.floor(value) - 1;
						if (monthIndex >= 0 && monthIndex < 12) {
							return months[monthIndex];
						}
						return '';
					},
					labelOffset: -15,
					stepSize: 1
				};
				mainChart.options.scales.y.min = 1;
				mainChart.options.scales.y.max = 13;
			} else if (yProp === 'elevationFt') {
				// Set elevation max to 12000
				mainChart.options.scales.y.max = 12000;
				mainChart.options.scales.y.ticks = {
					stepSize: 1000
				};
				mainChart.options.scales.y.min = 0;
			} else {
				mainChart.options.scales.y.ticks = {};
				mainChart.options.scales.y.min = undefined;
				mainChart.options.scales.y.max = undefined;
			}
			
			// Update chart data
			updateChartData(xProp, yProp);
			updateChartsForTheme();
			updateChartColors();
		}

		// Update chart data
		function updateChartData(xProp, yProp) {
			// Group data by dataset
			const datasetsMap = {};
			
			chartData.forEach(point => {
				if (!point.datasetId) {
					console.warn('Point missing datasetId:', point);
					return; // Skip points without datasetId
				}
				
				if (!datasetsMap[point.datasetId]) {
					datasetsMap[point.datasetId] = {
						label: point.datasetName || point.datasetId,
						data: [],
						backgroundColor: point.datasetColor,
						borderColor: point.datasetColor,
						borderWidth: 1,
						pointRadius: 2,
						pointHoverRadius: 2,
						datasetId: point.datasetId
					};
				}
				
				datasetsMap[point.datasetId].data.push(point);
			});
			
			// Convert to array
			const datasets = Object.values(datasetsMap);
			
			// Add user data if exists
			if (userData.length > 0) {
				datasets.push({
					label: 'Your Added Point',
					data: userData,
					backgroundColor: userPointColor,
					borderColor: userPointColor,
					borderWidth: 1,
					pointRadius: userPointSize,
					pointHoverRadius: userPointSize + 1,
					order: 0,
					datasetId: 'user_data'
				});
			}
			
			// Add highlighted point dataset if exists
			if (highlightedPoint) {
				const highlightDataset = {
					label: `id: ${highlightedPoint.observationUrl ? highlightedPoint.observationUrl.split('/').pop() : 'User Point'}`,
					data: [{
						x: highlightedPoint[xProp],
						y: highlightedPoint[yProp],
						...highlightedPoint
					}],
					backgroundColor: highlightColor,
					borderColor: highlightColor,
					borderWidth: 1,
					pointRadius: highlightPointSize,
					pointHoverRadius: highlightPointSize + 1,
					order: -1,
					datasetId: 'highlighted_point'
				};
				
				datasets.push(highlightDataset);
			}
			
			// Prepare datasets with filtered data
			mainChart.data.datasets = datasets.map(dataset => {
				// Skip highlighted dataset - it already has the right data
				if (dataset.datasetId === 'highlighted_point') {
					return dataset;
				}
				
				const filteredData = dataset.data
					.filter(point => point[xProp] !== null && point[yProp] !== null)
					.map(point => ({
						x: point[xProp],
						y: point[yProp],
						...point // Include all point properties
					}));
				
				// Set point size based on dataset type
				let pointRadius, pointHoverRadius;
				
				if (dataset.datasetId === 'user_data') {
					pointRadius = userPointSize;
					pointHoverRadius = userPointSize + 1;
				} else if (activeDatasets[dataset.datasetId]) {
					pointRadius = activeDatasets[dataset.datasetId].pointSize || pointSize;
					pointHoverRadius = pointRadius + 1;
				} else {
					pointRadius = pointSize;
					pointHoverRadius = pointSize + 1;
				}
				
				return {
					...dataset,
					data: filteredData,
					pointRadius: pointRadius,
					pointHoverRadius: pointHoverRadius,
					order: dataset.datasetId === 'user_data' ? 0 : 1
				};
			});
			
			mainChart.update();
		}

		// Helper function to get week number in a month (1-5)
		function getWeekInMonth(date) {
			const month = date.getMonth();
			const year = date.getFullYear();
			const day = date.getDate();
			
			// First day of the month
			const firstDay = new Date(year, month, 1);
			const firstDayOfWeek = firstDay.getDay(); // 0 = Sunday
			
			// Calculate which week of the month (1-5)
			return Math.ceil((day + firstDayOfWeek) / 7);
		}

		// Update histogram
		function updateHistogram() {
			const dimension = document.getElementById('histogram-dimension').value;
			const binCount = parseInt(document.getElementById('bin-count').value) || 15;
			const binOffset = parseInt(document.getElementById('bin-offset').value) || 0;

			// Reset x-axis ticks if not month dimension
			if (dimension !== 'month') {
				histogramChart.options.scales.x.ticks = {};
				histogramChart.options.plugins.tooltip.callbacks = {
					label: function(context) {
						const label = context.dataset.label || '';
						const value = context.parsed.y;
						const total = context.chart.data.datasets
							.map(ds => ds.data[context.dataIndex])
							.reduce((a, b) => a + b, 0);
						const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
						return `${label}: ${value} (${percentage}%)`;
					}
				};
			}
			
			// Get all active datasets
			const activeDatasetIds = Object.keys(activeDatasets).filter(id => activeDatasets[id].active);
			
			// Special handling for month and yearMonth dimensions
			if (dimension === 'month') {
				// For months split into weeks, create 60 bins (12 months √ó 5 weeks)
				const weekBins = Array(60).fill(0);
				const datasetsData = {};
				
				// Initialize data structure for each dataset
				activeDatasetIds.forEach(id => {
					datasetsData[id] = Array(60).fill(0);
				});
				
				// Count values per dataset per week
				allData.forEach(point => {
					if (point.date) {
						try {
							const date = new Date(point.date);
							const month = date.getMonth(); // 0-11
							const week = getWeekInMonth(date); // 1-5
							
							// Calculate bin index: (month * 5) + (week - 1)
							const binIndex = (month * 5) + (week - 1);
							
							if (binIndex >= 0 && binIndex < 60) {
								weekBins[binIndex]++;
								if (point.datasetId && datasetsData[point.datasetId]) {
									datasetsData[point.datasetId][binIndex]++;
								}
							}
						} catch (e) {
							console.error('Error parsing date:', point.date, e);
						}
					}
				});
				
				// Create month labels (one per month, not per week)
				const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
								   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
				const monthLabels = monthNames;
				
				// Apply offset
				let finalWeekLabels = [];
				let finalDatasetsData = {};

				// Create detailed week labels for tooltips
				for (let month = 0; month < 12; month++) {
					for (let week = 1; week <= 5; week++) {
						finalWeekLabels.push(`Week ${week}`);
					}
				}

				// Apply offset to the data (skip first N weeks)
				const startIndex = binOffset * 5; // Convert months to weeks (5 weeks per month)
				const totalWeeks = 60;

				activeDatasetIds.forEach(id => {
					// Get the weekly data
					const weeklyData = datasetsData[id] || Array(60).fill(0);
					
					// Apply offset by slicing the data
					const slicedData = weeklyData.slice(startIndex);
					
					// Store the sliced data
					finalDatasetsData[id] = slicedData;
				});

				// Apply same offset to labels
				const slicedWeekLabels = finalWeekLabels.slice(startIndex);

				// Update histogram with sliced data
				histogramChart.data.labels = slicedWeekLabels;
				histogramChart.data.datasets = [];

				// Create datasets for chart
				activeDatasetIds.forEach(id => {
					const datasetInfo = activeDatasets[id];
					histogramChart.data.datasets.push({
						label: datasetInfo.fileName,
						data: finalDatasetsData[id] || Array(slicedWeekLabels.length).fill(0),
						backgroundColor: datasetInfo.color,
						borderColor: datasetInfo.color,
						borderWidth: 1
					});
				});

				// Customize x-axis to show month names instead of week numbers
				histogramChart.options.scales.x.ticks = {
					callback: function(value, index, ticks) {
						// Calculate the original week index (accounting for offset)
						const originalIndex = index + startIndex;
						// Group every 5 weeks into a month
						const monthIndex = Math.floor(originalIndex / 5);
						const weekInMonth = originalIndex % 5;
						
						// Show month name in the middle week (week 3) of each month
						if (weekInMonth === 2) { // Week 3 (0-indexed: 0=W1, 1=W2, 2=W3, 3=W4, 4=W5)
							return monthNames[monthIndex] || '';
						}
						
						// Add a small tick mark at the start of each month (optional)
						if (weekInMonth === 0) {
							// You can return a small character or just empty string
							return '|';
						}
						
						return ''; // Don't show week numbers on x-axis
					},
					autoSkip: false,
					maxRotation: 0,
					padding: 10,
					// Add minor ticks between weeks
					minor: {
						enabled: true
					}
				};

				// Add grid lines between months for better visualization
				histogramChart.options.scales.x.grid = {
					...histogramChart.options.scales.x.grid,
					color: function(context) {
						// Calculate the original week index (accounting for offset)
						const originalIndex = context.index + startIndex;
						const weekInMonth = originalIndex % 5;
						
						// Draw a thicker line at the start of each month (between months)
						if (weekInMonth === 0 && context.index > 0) {
							return 'rgba(0, 0, 0, 0.3)'; // Darker line between months
						}
						
						// Draw medium line between weeks
						return 'rgba(0, 0, 0, 0.1)'; // Lighter line between weeks
					},
					lineWidth: function(context) {
						// Calculate the original week index (accounting for offset)
						const originalIndex = context.index + startIndex;
						const weekInMonth = originalIndex % 5;
						
						// Thicker line at month boundaries
						if (weekInMonth === 0 && context.index > 0) {
							return 2;
						}
						
						// Normal line between weeks
						return 1;
					}
				};
				
				// Customize tooltip to show week number
				histogramChart.options.plugins.tooltip.callbacks = {
					...histogramChart.options.plugins.tooltip.callbacks,
					title: function(context) {
						// Get the index of the hovered bar (accounting for offset)
						const index = context[0].dataIndex + startIndex;
						const monthIndex = Math.floor(index / 5);
						const weekNumber = (index % 5) + 1;
						return `${monthNames[monthIndex]} - Week ${weekNumber}`;
					},
					label: function(context) {
						const label = context.dataset.label || '';
						const value = context.parsed.y;
						const total = context.chart.data.datasets
							.map(ds => ds.data[context.dataIndex])
							.reduce((a, b) => a + b, 0);
						const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
						return `${label}: ${value} (${percentage}%)`;
					}
				};
				
			} else if (dimension === 'yearMonth') {
				// For year-month, group by unique values
				const uniqueValues = [...new Set(allData
					.filter(point => point[dimension] !== null && point[dimension] !== undefined)
					.map(point => point[dimension]))].sort();
				
				const datasetsData = {};
				
				// Initialize data structure for each dataset
				activeDatasetIds.forEach(id => {
					datasetsData[id] = Array(uniqueValues.length).fill(0);
				});
				
				// Count values per dataset
				allData.forEach(point => {
					if (point[dimension] !== null && point[dimension] !== undefined) {
						const valueIndex = uniqueValues.indexOf(point[dimension]);
						if (valueIndex !== -1) {
							if (point.datasetId && datasetsData[point.datasetId]) {
								datasetsData[point.datasetId][valueIndex]++;
							}
						}
					}
				});
				
				// Apply offset
				let finalLabels = uniqueValues;
				let finalDatasetsData = datasetsData;
				if (binOffset > 0) {
					finalLabels = uniqueValues.slice(binOffset);
					Object.keys(datasetsData).forEach(id => {
						finalDatasetsData[id] = datasetsData[id].slice(binOffset);
					});
				}
				
				// Create datasets for chart
				const datasets = [];
				activeDatasetIds.forEach(id => {
					const datasetInfo = activeDatasets[id];
					datasets.push({
						label: datasetInfo.fileName,
						data: finalDatasetsData[id] || Array(finalLabels.length).fill(0),
						backgroundColor: datasetInfo.color,
						borderColor: datasetInfo.color,
						borderWidth: 1
					});
				});
				
				// Update histogram
				histogramChart.data.labels = finalLabels;
				histogramChart.data.datasets = datasets;
				
			} else {
				// For numeric dimensions, create bins
				const values = allData
					.filter(point => point[dimension] !== null && point[dimension] !== undefined)
					.map(point => point[dimension]);
				
				if (values.length === 0) {
					histogramChart.data.labels = ['No data'];
					histogramChart.data.datasets = [];
					histogramChart.update();
					return;
				}
				
				const min = Math.min(...values);
				const max = Math.max(...values);
				const binSize = (max - min) / binCount;
				
				const datasetsData = {};
				
				// Initialize data structure for each dataset
				activeDatasetIds.forEach(id => {
					datasetsData[id] = Array(binCount).fill(0);
				});
				
				// Count values per dataset per bin
				allData.forEach(point => {
					if (point[dimension] !== null && point[dimension] !== undefined) {
						let binIndex = Math.floor((point[dimension] - min) / binSize);
						if (binIndex === binCount) binIndex = binCount - 1; // Handle edge case
						
						if (point.datasetId && datasetsData[point.datasetId]) {
							datasetsData[point.datasetId][binIndex]++;
						}
					}
				});
				
				// Create labels for bins with better formatting
				const labels = [];
				for (let i = 0; i < binCount; i++) {
					const binStart = min + (i * binSize);
					const binEnd = min + ((i + 1) * binSize);
					
					// Format based on dimension type
					if (dimension === 'elevationFt') {
						// Round to nearest 100 for clean numbers
						const roundedStart = Math.round(binStart / 100) * 100;
						const roundedEnd = Math.round(binEnd / 100) * 100;
						labels.push(`${roundedStart} - ${roundedEnd} ft`);
					} else if (dimension === 'soilTemp') {
						labels.push(`${Math.round(binStart)} - ${Math.round(binEnd)} ¬∞F`);
					} else if (dimension === 'soilMoisture') {
						labels.push(`${binStart.toFixed(2)} - ${binEnd.toFixed(2)}`);
					} else if (dimension === 'slopeDeg') {
						// Slope: Show rounded values and categorize
						const start = Math.round(binStart);
						const end = Math.round(binEnd);
						let slopeCategory = '';
						
						if (end <= 10) slopeCategory = ' (Gentle)';
						else if (end <= 20) slopeCategory = ' (Moderate)';
						else if (end <= 30) slopeCategory = ' (Steep)';
						else slopeCategory = ' (Very Steep)';
						
						labels.push(`${start} - ${end}¬∞${slopeCategory}`);
					} else if (dimension === 'slopeAspectDeg') {
						// Aspect: Show degrees and compass direction
						const start = Math.round(binStart);
						const end = Math.round(binEnd);
						
						// Convert to compass direction for the middle of the range
						const midPoint = (start + end) / 2;
						const compassDir = aspectToCompass(midPoint);
						
						labels.push(`${start} - ${end}¬∞ (${compassDir})`);
					} else {
						labels.push(`${binStart.toFixed(1)} - ${binEnd.toFixed(1)}`);
					}
				}
				
				// Apply offset
				let finalLabels = labels;
				let finalDatasetsData = datasetsData;
				if (binOffset > 0) {
					finalLabels = labels.slice(binOffset);
					Object.keys(datasetsData).forEach(id => {
						finalDatasetsData[id] = datasetsData[id].slice(binOffset);
					});
				}
				
				// Create datasets for chart
				const datasets = [];
				activeDatasetIds.forEach(id => {
					const datasetInfo = activeDatasets[id];
					datasets.push({
						label: datasetInfo.fileName,
						data: finalDatasetsData[id] || Array(finalLabels.length).fill(0),
						backgroundColor: datasetInfo.color,
						borderColor: datasetInfo.color,
						borderWidth: 1
					});
				});
				
				// Update histogram
				histogramChart.data.labels = finalLabels;
				histogramChart.data.datasets = datasets;
			}
			
			// Update axis label
			const dimensionLabels = {
				'elevationFt': 'Elevation (ft)',
				'soilTemp': 'Soil Temperature (¬∞F)',
				'soilMoisture': 'Soil Moisture',
				'slopeDeg': 'Slope (degrees)',
				'slopeAspectDeg': 'Aspect (degrees)',
				'month': 'Month',
				'yearMonth': 'Year-Month'
			};
			
			histogramChart.options.scales.x.title.text = dimensionLabels[dimension] || 'Value';
			updateChartsForTheme();
			histogramChart.update();
		}
        
		function updateVisualsOnly() {
			// Save current highlight state
			const currentHighlight = highlightedPoint;
			
			// Update main chart colors and sizes
			updateChartColors();
			
			// Update histogram colors
			if (histogramChart && histogramChart.data && histogramChart.data.datasets) {
				let needsUpdate = false;
				
				histogramChart.data.datasets.forEach(dataset => {
					// Find the corresponding dataset in activeDatasets
					const datasetId = Object.keys(activeDatasets).find(id => 
						activeDatasets[id].fileName === dataset.label
					);
					
					if (datasetId && activeDatasets[datasetId]) {
						const newColor = activeDatasets[datasetId].color;
						// Only update if color changed
						if (dataset.backgroundColor !== newColor) {
							dataset.backgroundColor = newColor;
							dataset.borderColor = newColor;
							needsUpdate = true;
						}
					}
				});
				
				// Only update if colors changed
				if (needsUpdate) {
					histogramChart.update();
				}
			}
			
			// Update ALL map points - not just colors
			updateMapPoints(); // This will recreate all points with updated sizes
			
			// Restore highlight if there was one
			if (currentHighlight) {
				setTimeout(() => {
					highlightPoint(currentHighlight);
				}, 100);
			}
		}

		function updateChartColors() {
			// Update main chart colors
			if (mainChart && mainChart.data && mainChart.data.datasets) {
				mainChart.data.datasets.forEach(dataset => {
					// Skip if no data or no datasetId
					if (!dataset.data || dataset.data.length === 0) return;
					
					// Skip highlighted datasets
					if (dataset.datasetId === 'highlighted_point') return;
					
					// Get the datasetId from the first data point
					const firstPoint = dataset.data[0];
					if (!firstPoint) return;
					
					if (firstPoint.datasetId === 'user_data') {
						// User data
						dataset.backgroundColor = userPointColor;
						dataset.borderColor = userPointColor;
						dataset.pointRadius = userPointSize;
						dataset.pointHoverRadius = userPointSize + 1;
					} else if (firstPoint.datasetId && activeDatasets[firstPoint.datasetId]) {
						// NDJSON dataset
						dataset.backgroundColor = activeDatasets[firstPoint.datasetId].color;
						dataset.borderColor = activeDatasets[firstPoint.datasetId].color;
						dataset.pointRadius = activeDatasets[firstPoint.datasetId].pointSize || pointSize;
						dataset.pointHoverRadius = (activeDatasets[firstPoint.datasetId].pointSize || pointSize) + 1;
					}
				});
				
				mainChart.update('none');
			}
		}

		function updateMapPointColors() {
			// If no markers exist yet, return early
			if (mapPoints.length === 0) return;
			
			// Save current highlight state
			const currentHighlight = highlightedPoint;
			
			// First, remove all highlights temporarily
			removeHighlights();
			
			// Simply update all map points
			updateMapPoints();
			
			// Re-apply highlight if there was one
			if (currentHighlight) {
				// Use a small delay to ensure markers are recreated
				setTimeout(() => {
					highlightPoint(currentHighlight);
				}, 100);
			}
		}

        // Update charts with current data
		function updateCharts() {
			// Get current axis selections
			const xProp = document.getElementById('x-axis').value;
			const yProp = document.getElementById('y-axis').value;
			
			updateChartData(xProp, yProp);
			updateHistogram();
		}
        
        // Populate data table
        function populateDataTable() {
            const tableBody = document.getElementById('table-body');
            tableBody.innerHTML = '';
            
            allData.forEach(point => {
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid #eee';
                row.style.cursor = 'pointer';
                
                row.onclick = function() {
                    showPointInfo(point);
                };
                
                // Highlight user-added data
                if (userData.includes(point)) {
                    row.style.backgroundColor = '#FFF5F5';
                }
                
				row.innerHTML = `
					<td style="padding: 10px; text-align: center;">${point.datasetName || 'User Data'}</td>
					<td style="padding: 10px; text-align: center;">${point.date}</td>
					<td style="padding: 10px; text-align: center;">${point.elevationFt}</td>
					<td style="padding: 10px; text-align: center;">${point.soilTemp ? point.soilTemp.toFixed(1) : 'N/A'}</td>
					<td style="padding: 10px; text-align: center;">${point.soilMoisture ? point.soilMoisture.toFixed(3) : 'N/A'}</td>
					<td style="padding: 10px; text-align: center;">${point.slopeDeg ? point.slopeDeg.toFixed(1) : 'N/A'}</td>
					<td style="padding: 10px; text-align: center;">${point.slopeAspectDeg ? point.slopeAspectDeg.toFixed(1) : 'N/A'}</td>
				`;
                
                tableBody.appendChild(row);
            });
        }
        
        // Show point information in the info panel
		async function showPointInfo(point) {
			highlightPoint(point);
			const infoPanel = document.getElementById('info-panel');
			const infoContent = document.getElementById('info-content');
			const soilTempChartContainer = document.getElementById('soil-temp-chart-container');
			
			const observationLink = point.observationUrl || '#';
			const apiUrl = point.rawData ? point.rawData.open_meteo_api_url : point.openMeteoApiUrl || '#';
			const docsUrl = point.rawData ? point.rawData.open_meteo_docs_url : point.openMeteoDocsUrl || '#';
			
			const slopeHTML =
				point.slopeDeg != null
					? `
					<div class="info-item">
						<span class="info-label">Slope:</span> ${point.slopeDeg.toFixed(1)}¬∞
					</div>`
					: '';

			const aspectHTML =
				point.slopeAspectDeg != null
					? `
					<div class="info-item">
						<span class="info-label">Aspect:</span>
						${point.slopeAspectDeg.toFixed(1)}¬∞ (${aspectToCompass(point.slopeAspectDeg)})
					</div>`
					: '';

			infoContent.innerHTML = `
				<div class="info-item">
					<span class="info-label">Dataset:</span> ${point.datasetName || 'User Data'}
				</div>
				<div class="info-item">
					<span class="info-label">Date:</span> ${point.date || 'N/A'}
				</div>
				<div class="info-item">
					<span class="info-label">Coordinates:</span> ${point.coordinates}
				</div>
				<div class="info-item">
					<span class="info-label">Elevation:</span> ${point.elevationFt} ft
				</div>
				<div class="info-item">
					<span class="info-label">Avg Soil Temp (${averageDays} days):</span>
					${point.soilTemp ? point.soilTemp.toFixed(1) : 'N/A'} ¬∞F (${tempDepth})
				</div>
				<div class="info-item">
					<span class="info-label">Avg Soil Moisture (${averageDays} days):</span>
					${point.soilMoisture ? point.soilMoisture.toFixed(3) : 'N/A'} (${moistureDepth})
				</div>
				${slopeHTML}
				${aspectHTML}
				<div class="info-item">
					<span class="info-label">Observation Link:</span>
					<a href="${observationLink}" target="_blank" class="link">${observationLink}</a>
				</div>
				<div class="info-item">
					<span class="info-label">Open-Meteo Docs:</span>
					<a href="${docsUrl}" target="_blank" class="link">
						https://open-meteo.com/docs...
					</a>
				</div>
			`;
			
			infoPanel.classList.add('active');

			// Display soil temperature and moisture chart from NDJSON data if available
			if (point.rawData && point.rawData.dates && point.rawData.soil_temperature && point.rawData.soil_moisture) {
				displaySoilTempMoistureChart(point.rawData, point);
			} else if (apiUrl && apiUrl !== '#') {
				// Fall back to API for user-added points
				try {
					const response = await fetch(apiUrl);
					if (response.ok) {
						const data = await response.json();
						displaySoilTempMoistureChart(data, point);
					}
				} catch (error) {
					console.error('Error fetching soil temperature data:', error);
				}
			}
			
			if (enableScroll) {
				infoPanel.scrollIntoView({ behavior: 'smooth' });
			}
			updateChartsForTheme();
		}
        
        // Create the soil temperature and moisture chart from NDJSON data
		function displaySoilTempMoistureChart(data, point) {
			const ctx = document.getElementById('soil-temp-chart').getContext('2d');
			const soilTempChartContainer = document.getElementById('soil-temp-chart-container');
			
			// Update the chart title to show the current average days
			const chartTitle = soilTempChartContainer.querySelector('h4');
			if (chartTitle) {
				chartTitle.textContent = `Soil Temperature & Moisture Trend (Last ${averageDays} Days)`;
			}
			
			if (window.soilTempChart) {
				window.soilTempChart.destroy();
			}
			
			let dates, temps, moistures;
			let usedTempVariable = '';
			let usedMoistureVariable = '';
			
			// Check data structure type
			if (data.dates && data.soil_temperature && data.soil_moisture) {
				// NDJSON data structure
				usedTempVariable = `soil_temperature_${tempDepth}`;
				usedMoistureVariable = `soil_moisture_${moistureDepth}`;
				
				dates = data.dates;
				
				// Get temperature data for the selected depth
				switch(tempDepth) {
					case '0_to_7cm':
						temps = data.soil_temperature['0_to_7cm'];
						break;
					case '7_to_28cm':
						temps = data.soil_temperature['7_to_28cm'];
						break;
					case '28_to_100cm':
						temps = data.soil_temperature['28_to_100cm'];
						break;
					case '0_to_100cm':
						temps = data.soil_temperature['0_to_100cm'];
						break;
					default:
						temps = data.soil_temperature['7_to_28cm'];
				}
				
				// Get moisture data for the selected depth
				switch(moistureDepth) {
					case '0_to_7cm':
						moistures = data.soil_moisture['0_to_7cm'];
						break;
					case '7_to_28cm':
						moistures = data.soil_moisture['7_to_28cm'];
						break;
					case '28_to_100cm':
						moistures = data.soil_moisture['28_to_100cm'];
						break;
					case '0_to_100cm':
						moistures = data.soil_moisture['0_to_100cm'];
						break;
					default:
						moistures = data.soil_moisture['7_to_28cm'];
				}
				
			} else if (data.daily) {
				// Historical API data structure
				usedTempVariable = `soil_temperature_${tempDepth}_mean`;
				usedMoistureVariable = `soil_moisture_${moistureDepth}_mean`;
				
				dates = data.daily.time;
				
				// Get temperature data for the selected depth
				switch(tempDepth) {
					case '0_to_7cm':
						temps = data.daily.soil_temperature_0_to_7cm_mean;
						break;
					case '7_to_28cm':
						temps = data.daily.soil_temperature_7_to_28cm_mean;
						break;
					case '28_to_100cm':
						temps = data.daily.soil_temperature_28_to_100cm_mean;
						break;
					case '0_to_100cm':
						temps = data.daily.soil_temperature_0_to_100cm_mean;
						break;
					default:
						temps = data.daily.soil_temperature_7_to_28cm_mean;
				}
				
				// Get moisture data for the selected depth
				switch(moistureDepth) {
					case '0_to_7cm':
						moistures = data.daily.soil_moisture_0_to_7cm_mean;
						break;
					case '7_to_28cm':
						moistures = data.daily.soil_moisture_7_to_28cm_mean;
						break;
					case '28_to_100cm':
						moistures = data.daily.soil_moisture_28_to_100cm_mean;
						break;
					case '0_to_100cm':
						moistures = data.daily.soil_moisture_0_to_100cm_mean;
						break;
					default:
						moistures = data.daily.soil_moisture_7_to_28cm_mean;
				}
			} else if (data.hourly) {
				// Forecast API data structure (hourly data)
				dates = data.hourly.time;
				
				// Get temperature data for the selected depth - use exact forecast API variables
				switch(tempDepth) {
					case '0_to_7cm':
						// Use soil_temperature_6cm for 0-7cm approximation
						usedTempVariable = 'soil_temperature_6cm';
						temps = data.hourly.soil_temperature_6cm;
						break;
					case '7_to_28cm':
						// Use soil_temperature_18cm for 7-28cm approximation
						usedTempVariable = 'soil_temperature_18cm';
						temps = data.hourly.soil_temperature_18cm;
						break;
					case '28_to_100cm':
						// Use soil_temperature_54cm for 28-100cm approximation
						usedTempVariable = 'soil_temperature_54cm';
						temps = data.hourly.soil_temperature_54cm;
						break;
					case '0_to_100cm':
						// Average all available temperature depths
						usedTempVariable = 'soil_temperature_0cm + 6cm + 18cm + 54cm average';
						const allTemps = [];
						if (data.hourly.soil_temperature_0cm) allTemps.push(data.hourly.soil_temperature_0cm);
						if (data.hourly.soil_temperature_6cm) allTemps.push(data.hourly.soil_temperature_6cm);
						if (data.hourly.soil_temperature_18cm) allTemps.push(data.hourly.soil_temperature_18cm);
						if (data.hourly.soil_temperature_54cm) allTemps.push(data.hourly.soil_temperature_54cm);
						
						// Calculate hourly averages across depths
						if (allTemps.length > 0) {
							const hourlyCount = allTemps[0].length;
							temps = [];
							for (let i = 0; i < hourlyCount; i++) {
								let sum = 0;
								let count = 0;
								allTemps.forEach(depthTemps => {
									if (depthTemps[i] !== undefined) {
										sum += depthTemps[i];
										count++;
									}
								});
								temps.push(sum / count);
							}
						} else {
							temps = [];
						}
						break;
					default:
						usedTempVariable = 'soil_temperature_18cm';
						temps = data.hourly.soil_temperature_18cm;
				}
				
				// Get moisture data for the selected depth - use exact forecast API variables
				switch(moistureDepth) {
					case '0_to_7cm':
						// Use average of soil_moisture_0_to_1cm, 1_to_3cm, 3_to_9cm for 0-7cm approximation
						usedMoistureVariable = 'soil_moisture_0_to_1cm + 1_to_3cm + 3_to_9cm average';
						const moisture0to7cm = [];
						const hourlyCount = data.hourly.time.length;
						
						for (let i = 0; i < hourlyCount; i++) {
							let sum = 0;
							let count = 0;
							
							if (data.hourly.soil_moisture_0_to_1cm && data.hourly.soil_moisture_0_to_1cm[i] !== undefined) {
								sum += data.hourly.soil_moisture_0_to_1cm[i];
								count++;
							}
							if (data.hourly.soil_moisture_1_to_3cm && data.hourly.soil_moisture_1_to_3cm[i] !== undefined) {
								sum += data.hourly.soil_moisture_1_to_3cm[i];
								count++;
							}
							if (data.hourly.soil_moisture_3_to_9cm && data.hourly.soil_moisture_3_to_9cm[i] !== undefined) {
								sum += data.hourly.soil_moisture_3_to_9cm[i];
								count++;
							}
							
							moisture0to7cm.push(count > 0 ? sum / count : null);
						}
						moistures = moisture0to7cm;
						break;
						
					case '7_to_28cm':
						// Use soil_moisture_9_to_27cm for 7-28cm approximation
						usedMoistureVariable = 'soil_moisture_9_to_27cm';
						moistures = data.hourly.soil_moisture_9_to_27cm;
						break;
						
					case '28_to_100cm':
						// Use soil_moisture_27_to_81cm for 28-100cm approximation
						usedMoistureVariable = 'soil_moisture_27_to_81cm';
						moistures = data.hourly.soil_moisture_27_to_81cm;
						break;
						
					case '0_to_100cm':
						// Average all available moisture depths
						usedMoistureVariable = 'soil_moisture_all_depths_average';
						const allMoistures = [];
						if (data.hourly.soil_moisture_0_to_1cm) allMoistures.push(data.hourly.soil_moisture_0_to_1cm);
						if (data.hourly.soil_moisture_1_to_3cm) allMoistures.push(data.hourly.soil_moisture_1_to_3cm);
						if (data.hourly.soil_moisture_3_to_9cm) allMoistures.push(data.hourly.soil_moisture_3_to_9cm);
						if (data.hourly.soil_moisture_9_to_27cm) allMoistures.push(data.hourly.soil_moisture_9_to_27cm);
						if (data.hourly.soil_moisture_27_to_81cm) allMoistures.push(data.hourly.soil_moisture_27_to_81cm);
						
						// Calculate hourly averages across depths
						if (allMoistures.length > 0) {
							const hourlyCount = allMoistures[0].length;
							moistures = [];
							for (let i = 0; i < hourlyCount; i++) {
								let sum = 0;
								let count = 0;
								allMoistures.forEach(depthMoistures => {
									if (depthMoistures[i] !== undefined) {
										sum += depthMoistures[i];
										count++;
									}
								});
								moistures.push(count > 0 ? sum / count : null);
							}
						} else {
							moistures = [];
						}
						break;
						
					default:
						usedMoistureVariable = 'soil_moisture_9_to_27cm';
						moistures = data.hourly.soil_moisture_9_to_27cm;
				}
				
			} else {
				console.error('Unknown data structure:', data);
				return;
			}
			
			// Update chart title to show which variables are being used
			if (data.hourly && chartTitle) {
				chartTitle.textContent = `Soil Temperature & Moisture Trend (Last ${averageDays} Days) - Forecast API: ${usedTempVariable}, ${usedMoistureVariable}`;
			}
			
			// LIMIT DATA TO ONLY THE LAST averageDays
			// For hourly data, we need to convert days to hours (averageDays * 24)
			const isHourlyData = data.hourly !== undefined;
			const dataPointsToShow = isHourlyData ? averageDays * 24 : averageDays;
			const startIdx = Math.max(0, dates.length - dataPointsToShow);
			
			// Slice the arrays to only show the specified number of data points
			dates = dates.slice(startIdx);
			temps = temps ? temps.slice(startIdx) : [];
			moistures = moistures ? moistures.slice(startIdx) : [];
			
			// Filter out null/undefined values for average calculation
			const validTemps = temps.filter(temp => temp != null);
			const validMoistures = moistures.filter(moisture => moisture != null);
			
			// Calculate averages based on the sliced data
			const avgTemp = validTemps.length > 0 ? validTemps.reduce((sum, temp) => sum + temp, 0) / validTemps.length : 0;
			const avgMoisture = validMoistures.length > 0 ? validMoistures.reduce((sum, moisture) => sum + moisture, 0) / validMoistures.length : 0;
			
			// Make sure container is visible before creating chart
			soilTempChartContainer.style.display = 'block';
			
			// Create chart with two Y-axes
			window.soilTempChart = new Chart(ctx, {
				type: 'line',
				data: {
					labels: dates.map(dateStr => {
						const d = new Date(dateStr);
						if (isHourlyData) {
							return `${d.getMonth() + 1}/${d.getDate()} ${d.getHours()}:00`;
						} else {
							return `${d.getMonth() + 1}/${d.getDate()}`;
						}
					}),
					datasets: [
						{
							label: `Soil Temperature (${usedTempVariable}) ¬∞F`,
							data: temps,
							borderColor: '#8B4513',
							backgroundColor: 'rgba(139, 69, 19, 0.1)',
							borderWidth: 2,
							fill: true,
							tension: 0.3,
							yAxisID: 'y-temp'
						},
						{
							label: `Soil Moisture (${usedMoistureVariable})`,
							data: moistures,
							borderColor: '#1E90FF',
							backgroundColor: 'rgba(30, 144, 255, 0.1)',
							borderWidth: 2,
							fill: true,
							tension: 0.3,
							yAxisID: 'y-moisture'
						},
						{
							label: `Avg Temp: ${avgTemp.toFixed(1)}¬∞F`,
							data: temps.map(() => avgTemp),
							borderColor: '#8B4513',
							borderWidth: 1,
							borderDash: [5, 5],
							fill: false,
							pointRadius: 0,
							yAxisID: 'y-temp'
						},
						{
							label: `Avg Moisture: ${avgMoisture.toFixed(3)}`,
							data: moistures.map(() => avgMoisture),
							borderColor: '#1E90FF',
							borderWidth: 1,
							borderDash: [5, 5],
							fill: false,
							pointRadius: 0,
							yAxisID: 'y-moisture'
						}
					]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: {
							display: true,
							position: 'top',
							labels: {
								boxWidth: 12,
								padding: 10,
								font: {
									size: 11
								}
							}
						},
						tooltip: {
							mode: 'index',
							intersect: false,
							callbacks: {
								label: function(context) {
									let label = context.dataset.label || '';
									if (label) {
										label += ': ';
									}
									if (context.dataset.label.includes('Temperature')) {
										label += context.parsed.y.toFixed(1) + '¬∞F';
									} else if (context.dataset.label.includes('Moisture')) {
										label += context.parsed.y.toFixed(3);
									} else {
										label += context.parsed.y.toFixed(2);
									}
									return label;
								}
							}
						}
					},
					scales: {
						x: {
							title: {
								display: true,
								text: isHourlyData ? 'Date & Time (Local)' : 'Date'
							},
							grid: {
								color: 'rgba(0, 0, 0, 0.05)'
							}
						},
						'y-temp': {
							type: 'linear',
							display: true,
							position: 'left',
							title: {
								display: true,
								text: 'Temperature (¬∞F)',
								color: '#8B4513'
							},
							ticks: {
								color: '#8B4513'
							},
							grid: {
								drawOnChartArea: false
							}
						},
						'y-moisture': {
							type: 'linear',
							display: true,
							position: 'right',
							title: {
								display: true,
								text: 'Soil Moisture',
								color: '#1E90FF'
							},
							ticks: {
								color: '#1E90FF'
							},
							grid: {
								drawOnChartArea: false
							}
						}
					}
				}
			});
			
			// Force chart to update after a tiny delay to ensure container is visible
			setTimeout(() => {
				if (window.soilTempChart) {
					window.soilTempChart.update();
				}
			}, 50);
		}
        
        // Fetch data from Open-Meteo API for user-added points
		async function fetchOpenMeteoData(latitude, longitude, date) {
			removeHighlights();
			const loadingDiv = document.getElementById('loading');
			loadingDiv.style.display = 'block';
			
			try {
				const observationDate = new Date(date);
				const startDate = new Date(observationDate);
				startDate.setDate(observationDate.getDate() - averageDays);
				
				const startDateStr = startDate.toISOString().split('T')[0];
				const endDateStr = observationDate.toISOString().split('T')[0];
				
				// Calculate if we need forecast API (within last 5 days from today)
				const today = new Date();
				const fiveDaysAgo = new Date();
				fiveDaysAgo.setDate(today.getDate() - 5);
				
				let apiUrl, docsUrl;
				let isForecastAPI = false;
				
				if (observationDate > fiveDaysAgo) {
					// Use forecast API for recent dates (within last 5 days)
					isForecastAPI = true;
					apiUrl = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=soil_temperature_0cm,soil_temperature_6cm,soil_temperature_18cm,soil_temperature_54cm,soil_moisture_0_to_1cm,soil_moisture_1_to_3cm,soil_moisture_3_to_9cm,soil_moisture_9_to_27cm,soil_moisture_27_to_81cm&past_days=${averageDays}&forecast_days=0&temperature_unit=fahrenheit`;
					docsUrl = `https://open-meteo.com/en/docs?latitude=${latitude}&longitude=${longitude}&forecast_days=0&past_days=${averageDays}&hourly=soil_temperature_0cm,soil_temperature_6cm,soil_temperature_18cm,soil_temperature_54cm,soil_moisture_0_to_1cm,soil_moisture_1_to_3cm,soil_moisture_3_to_9cm,soil_moisture_9_to_27cm,soil_moisture_27_to_81cm&temperature_unit=fahrenheit`;
				} else {
					// Use historical API for older dates
					apiUrl = `https://archive-api.open-meteo.com/v1/archive?latitude=${latitude}&longitude=${longitude}&start_date=${startDateStr}&end_date=${endDateStr}&daily=soil_temperature_0_to_7cm_mean,soil_temperature_7_to_28cm_mean,soil_temperature_28_to_100cm_mean,soil_temperature_0_to_100cm_mean,soil_moisture_0_to_7cm_mean,soil_moisture_7_to_28cm_mean,soil_moisture_28_to_100cm_mean,soil_moisture_0_to_100cm_mean&timezone=America%2FLos_Angeles&temperature_unit=fahrenheit&wind_speed_unit=mph&precipitation_unit=inch`;
					docsUrl = apiUrl.replace('archive-api.open-meteo.com/v1/archive', 'open-meteo.com/en/docs/historical-weather-api');
				}
				
				const response = await fetch(apiUrl);
				
				if (!response.ok) {
					throw new Error(`API error: ${response.status}`);
				}
				
				const data = await response.json();
				
				// Calculate averages based on which API was used
				const depthAverages = {};
				
				if (isForecastAPI) {
					// Forecast API - hourly data with different depth parameters
					const hourlyData = data.hourly;
					
					// Map forecast API depths to our depth categories
					// We'll use 6cm as 0-7cm, 18cm as 7-28cm, 54cm as 28-100cm
					// And average appropriate depths for 0-100cm
					
					if (hourlyData.soil_temperature_6cm) {
						// 0-7cm ‚âà 6cm
						const temps = hourlyData.soil_temperature_6cm;
						depthAverages['temp_0_to_7cm'] = temps.reduce((sum, temp) => sum + temp, 0) / temps.length;
					}
					
					if (hourlyData.soil_temperature_18cm) {
						// 7-28cm ‚âà 18cm
						const temps = hourlyData.soil_temperature_18cm;
						depthAverages['temp_7_to_28cm'] = temps.reduce((sum, temp) => sum + temp, 0) / temps.length;
					}
					
					if (hourlyData.soil_temperature_54cm) {
						// 28-100cm ‚âà 54cm
						const temps = hourlyData.soil_temperature_54cm;
						depthAverages['temp_28_to_100cm'] = temps.reduce((sum, temp) => sum + temp, 0) / temps.length;
					}
					
					// Calculate 0-100cm average from available depths
					const tempDepths = [];
					if (hourlyData.soil_temperature_0cm) tempDepths.push(...hourlyData.soil_temperature_0cm);
					if (hourlyData.soil_temperature_6cm) tempDepths.push(...hourlyData.soil_temperature_6cm);
					if (hourlyData.soil_temperature_18cm) tempDepths.push(...hourlyData.soil_temperature_18cm);
					if (hourlyData.soil_temperature_54cm) tempDepths.push(...hourlyData.soil_temperature_54cm);
					
					if (tempDepths.length > 0) {
						depthAverages['temp_0_to_100cm'] = tempDepths.reduce((sum, temp) => sum + temp, 0) / tempDepths.length;
					}
					
					// Soil moisture - similar mapping
					if (hourlyData.soil_moisture_1_to_3cm) {
						// 0-7cm ‚âà average of 0-1cm, 1-3cm, 3-9cm
						const moistures = [
							...(hourlyData.soil_moisture_0_to_1cm || []),
							...hourlyData.soil_moisture_1_to_3cm,
							...(hourlyData.soil_moisture_3_to_9cm || [])
						];
						if (moistures.length > 0) {
							depthAverages['moisture_0_to_7cm'] = moistures.reduce((sum, m) => sum + m, 0) / moistures.length;
						}
					}
					
					if (hourlyData.soil_moisture_9_to_27cm) {
						// 7-28cm ‚âà 9-27cm
						const moistures = hourlyData.soil_moisture_9_to_27cm;
						depthAverages['moisture_7_to_28cm'] = moistures.reduce((sum, m) => sum + m, 0) / moistures.length;
					}
					
					if (hourlyData.soil_moisture_27_to_81cm) {
						// 28-100cm ‚âà 27-81cm
						const moistures = hourlyData.soil_moisture_27_to_81cm;
						depthAverages['moisture_28_to_100cm'] = moistures.reduce((sum, m) => sum + m, 0) / moistures.length;
					}
					
					// Calculate 0-100cm moisture average from all available depths
					const moistureDepths = [];
					if (hourlyData.soil_moisture_0_to_1cm) moistureDepths.push(...hourlyData.soil_moisture_0_to_1cm);
					if (hourlyData.soil_moisture_1_to_3cm) moistureDepths.push(...hourlyData.soil_moisture_1_to_3cm);
					if (hourlyData.soil_moisture_3_to_9cm) moistureDepths.push(...hourlyData.soil_moisture_3_to_9cm);
					if (hourlyData.soil_moisture_9_to_27cm) moistureDepths.push(...hourlyData.soil_moisture_9_to_27cm);
					if (hourlyData.soil_moisture_27_to_81cm) moistureDepths.push(...hourlyData.soil_moisture_27_to_81cm);
					
					if (moistureDepths.length > 0) {
						depthAverages['moisture_0_to_100cm'] = moistureDepths.reduce((sum, m) => sum + m, 0) / moistureDepths.length;
					}
					
				} else {
					// Historical API - daily data
					// Temperature averages
					['0_to_7cm', '7_to_28cm', '28_to_100cm', '0_to_100cm'].forEach(depth => {
						const key = `soil_temperature_${depth}_mean`;
						if (data.daily[key]) {
							const temps = data.daily[key];
							depthAverages[`temp_${depth}`] = temps.reduce((sum, temp) => sum + temp, 0) / temps.length;
						}
					});
					
					// Moisture averages
					['0_to_7cm', '7_to_28cm', '28_to_100cm', '0_to_100cm'].forEach(depth => {
						const key = `soil_moisture_${depth}_mean`;
						if (data.daily[key]) {
							const moistures = data.daily[key];
							depthAverages[`moisture_${depth}`] = moistures.reduce((sum, moisture) => sum + moisture, 0) / moistures.length;
						}
					});
				}
				
				// Get elevation
				const elevation = data.elevation;
				const elevationFt = elevation * 3.28084;
				
				// Extract date components - FIXED: monthFraction was off by 1
				const dayOfMonth = observationDate.getDate();
				const monthFraction = (observationDate.getMonth() + 1) + (dayOfMonth / 31); // Now month starts at 1 (Jan), not 0
				
				// Create new data point
				const newPoint = {
					datasetId: 'user_data',
					datasetName: 'User Data',
					datasetColor: userPointColor,
					observationUrl: '#',
					date: endDateStr,
					coordinates: `${latitude.toFixed(6)}, ${longitude.toFixed(6)}`,
					elevationFt: Math.round(elevationFt),
					soilTemp: depthAverages[`temp_${tempDepth}`],
					soilMoisture: depthAverages[`moisture_${moistureDepth}`],
					month: observationDate.getMonth() + 1,
					monthName: observationDate.toLocaleString('default', { month: 'short' }),
					monthDay: dayOfMonth,
					monthFraction: monthFraction, // Now correct: 12.xx for December, not 11.xx
					yearMonth: observationDate.getFullYear() + '-' + 
								String(observationDate.getMonth() + 1).padStart(2, '0'),
					latitude: latitude,
					longitude: longitude,
					openMeteoApiUrl: apiUrl,
					openMeteoDocsUrl: docsUrl,
					depthAverages: depthAverages,
					isForecastData: isForecastAPI // Add flag for reference
				};
				
				// Clear previous user data and add new point
				userData = [newPoint];
				allData = [...originalData, ...userData];
				
				updateCharts(); // Just update charts with current data
				updateChartColors();
				populateDataTable(); // Update table

				// Update map points to include the new user point
				updateMapPoints();
				
				// Show info for the new point
				showPointInfo(newPoint);
				removeHighlights();
				
			} catch (error) {
				console.error('Error fetching Open-Meteo data:', error);
				alert(`Error fetching data: ${error.message}\n\nNote: The Open-Meteo API may not have data for the selected date range or location. Try a different date or coordinates.`);
			} finally {
				loadingDiv.style.display = 'none';
			}
		}
        
		// Theme switching functionality
		document.addEventListener('DOMContentLoaded', function() {
			// User and highlight point sizes
			['user-point-size', 'highlight-point-size'].forEach(id => {
				const input = document.getElementById(id);
				if (input) makeInputScrollable(input, 1, 20, 1);
			});
			
			// Bin controls
			const binCountInput = document.getElementById('bin-count');
			if (binCountInput) {
				makeInputScrollable(binCountInput, 1, 100, 1, function() {
					// Force histogram update when scrolled
					updateHistogram();
				});
				
				// Ensure both input and change events trigger update
				binCountInput.addEventListener('input', updateHistogram);
				binCountInput.addEventListener('change', updateHistogram);
			}

			// Apply to bin offset input
			const binOffsetInput = document.getElementById('bin-offset');
			if (binOffsetInput) {
				makeInputScrollable(binOffsetInput, 0, 100, 1, function() {
					// Force histogram update when scrolled
					updateHistogram();
				});
				
				// Ensure both input and change events trigger update
				binOffsetInput.addEventListener('input', updateHistogram);
				binOffsetInput.addEventListener('change', updateHistogram);
			}

			const themeToggle = document.getElementById('theme-toggle');
			const themeIcon = themeToggle.querySelector('i');
			const themeLabel = themeToggle.querySelector('.theme-label');
			
			// Check for saved theme preference or default to light
			const savedTheme = localStorage.getItem('theme') || 'light';
			document.documentElement.setAttribute('data-theme', savedTheme);
			updateThemeButton(savedTheme);
			
			// Also apply map theme if saved
			const savedMapLayer = localStorage.getItem('mapLayer');
			if (savedMapLayer && tileLayers[savedMapLayer]) {
				currentBaseLayer = savedMapLayer;
				if (map) {
					updateTileLayer();
				}
			}
			
			// Toggle theme on button click
			themeToggle.addEventListener('click', function() {
				const currentTheme = document.documentElement.getAttribute('data-theme');
				const newTheme = currentTheme === 'light' ? 'dark' : 'light';
				
				document.documentElement.setAttribute('data-theme', newTheme);
				localStorage.setItem('theme', newTheme);
				updateThemeButton(newTheme);
				
				// Update map layer based on theme
				updateMapLayerForTheme(newTheme);
				
				// Update charts if they exist
				updateChartsForTheme();
			});
			
			function updateThemeButton(theme) {
				if (theme === 'dark') {
					themeIcon.className = 'fas fa-sun';
					themeLabel.textContent = 'Light Mode';
					themeToggle.title = 'Switch to light mode';
				} else {
					themeIcon.className = 'fas fa-moon';
					themeLabel.textContent = 'Dark Mode';
					themeToggle.title = 'Switch to dark mode';
				}
			}
			
			// Function to update map layer based on theme
			function updateMapLayerForTheme(theme) {
				if (!map) return;
				
				// Save current view state
				const currentCenter = map.getCenter();
				const currentZoom = map.getZoom();
				
				if (theme === 'dark') {
					// Always use osm_medgray for dark theme
					const newLayer = 'osm_medgray';
					currentBaseLayer = newLayer;
					
					const layerSelector = document.querySelector('#layer-selector');
					if (layerSelector) {
						layerSelector.value = newLayer;
					}
				} else {
					// For light theme, use the first light map (or restore previous light map)
					const lightMaps = layerGroups.light.filter(layer => !layerGroups.dark.includes(layer) || layer !== currentBaseLayer);
					const newLayer = lightMaps.length > 0 ? lightMaps[0] : 'osm_std';
					
					currentBaseLayer = newLayer;
					const layerSelector = document.querySelector('#layer-selector');
					if (layerSelector) {
						layerSelector.value = newLayer;
					}
				}
				
				updateTileLayer();
				
				// Restore view
				map.setView(currentCenter, currentZoom);
				
				// Save preference
				localStorage.setItem('mapLayer', currentBaseLayer);
			}
			
			window.updateChartsForTheme = function() {
				// Update Chart.js charts with new theme colors
				if (mainChart) {
					const theme = document.documentElement.getAttribute('data-theme');
					const textColor = theme === 'dark' ? '#e0e0e0' : '#666';
					const gridColor = theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';
					
					// Update main chart
					mainChart.options.scales.x.grid.color = gridColor;
					mainChart.options.scales.y.grid.color = gridColor;
					mainChart.options.scales.x.ticks.color = textColor;
					mainChart.options.scales.y.ticks.color = textColor;
					mainChart.options.scales.x.title.color = textColor;
					mainChart.options.scales.y.title.color = textColor;
					mainChart.options.plugins.legend.labels.color = textColor;
					mainChart.update();
				}
				
				if (histogramChart) {
					const theme = document.documentElement.getAttribute('data-theme');
					const textColor = theme === 'dark' ? '#e0e0e0' : '#666';
					const gridColor = theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';
					
					// Update histogram chart
					histogramChart.options.scales.x.grid.color = gridColor;
					histogramChart.options.scales.y.grid.color = gridColor;
					histogramChart.options.scales.x.ticks.color = textColor;
					histogramChart.options.scales.y.ticks.color = textColor;
					histogramChart.options.scales.x.title.color = textColor;
					histogramChart.options.scales.y.title.color = textColor;
					histogramChart.options.plugins.legend.labels.color = textColor;
					histogramChart.update();
				}
				
				if (window.soilTempChart) {
					const theme = document.documentElement.getAttribute('data-theme');
					const textColor = theme === 'dark' ? '#e0e0e0' : '#666';
					const gridColor = theme === 'dark' ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.05)';
					
					// Update soil temp chart
					window.soilTempChart.options.scales.x.grid.color = gridColor;
					window.soilTempChart.options.scales.x.ticks.color = textColor;
					window.soilTempChart.options.scales.x.title.color = textColor;
					window.soilTempChart.options.scales['y-temp'].title.color = textColor;
					window.soilTempChart.options.scales['y-temp'].ticks.color = textColor;
					window.soilTempChart.options.scales['y-moisture'].title.color = textColor;
					window.soilTempChart.options.scales['y-moisture'].ticks.color = textColor;
					window.soilTempChart.options.plugins.legend.labels.color = textColor;
					window.soilTempChart.update();
				}
			}

			// Update charts when they're created
			const originalInitCharts = initCharts;
			initCharts = function() {
				originalInitCharts();
				updateChartsForTheme();
			};
			// Set random light map on first load
			setTimeout(() => {
				const savedMapLayer = localStorage.getItem('mapLayer');
				if (!savedMapLayer) {
					// Pick a random light map from the light group (excluding dark maps)
					const availableLightMaps = layerGroups.light.filter(layer => !layerGroups.dark.includes(layer));
					if (availableLightMaps.length > 0) {
						const randomLightMap = availableLightMaps[Math.floor(Math.random() * availableLightMaps.length)];
						currentBaseLayer = randomLightMap;
						localStorage.setItem('mapLayer', randomLightMap);
						
						// Update selector if map is initialized
						if (map) {
							const layerSelector = document.querySelector('#layer-selector');
							if (layerSelector) {
								layerSelector.value = randomLightMap;
							}
							updateTileLayer();
						}
					}
				}
			}, 500);
		});

        // Initialize the application
		document.addEventListener('DOMContentLoaded', async function() {
			try {
				// Initialize NDJSON directory
				initNdjsonDirectory();
				
				// Initialize the rest of the application
				initMap();
				initCharts();

				// Set default chart type
				setTimeout(() => {
					setDefaultAxes();
					updateHistogram();
				}, 100);
				
				// Load all three King Bolete files automatically since they're enabled by default
				setTimeout(() => {
					const kingBoleteFiles = ['Washington_Boletus_edulis.ndjson', 
											 'Oregon_Boletus_edulis.ndjson', 
											 'California_Boletus_edulis.ndjson'];
					
					let loadedCount = 0;
					const totalFiles = kingBoleteFiles.length;
					
					kingBoleteFiles.forEach(fileName => {
						// Find each King Bolete file
						const fileId = Object.keys(activeDatasets).find(key => 
							activeDatasets[key].fileName === fileName
						);
						
						if (fileId && activeDatasets[fileId].active) {
							loadNdjsonFile(fileId, activeDatasets[fileId].filePath).then(() => {
								loadedCount++;
								
								// After loading all files, create the map points
								if (loadedCount === totalFiles) {
									updateMapPoints();
									// Update folder counts
									updateFolderFileCounts();
								}
							});
						} else {
							loadedCount++;
							if (loadedCount === totalFiles) {
								updateFolderFileCounts();
							}
						}
					});
				}, 300); // Small delay to ensure everything is initialized
				
				// Add event listener for the fetch data button
				document.getElementById('fetch-data').addEventListener('click', function() {
					const latitude = parseFloat(document.getElementById('latitude').value);
					const longitude = parseFloat(document.getElementById('longitude').value);
					const date = document.getElementById('date').value;
					
					if (isNaN(latitude) || isNaN(longitude)) {
						alert('Please enter valid latitude and longitude values.');
						return;
					}
					
					if (!date) {
						alert('Please select a date.');
						return;
					}
					
					fetchOpenMeteoData(latitude, longitude, date);
				});
				
				// Add event listener for Enter key in input fields
				document.getElementById('latitude').addEventListener('keypress', function(e) {
					if (e.key === 'Enter') {
						document.getElementById('fetch-data').click();
					}
				});
				
				document.getElementById('longitude').addEventListener('keypress', function(e) {
					if (e.key === 'Enter') {
						document.getElementById('fetch-data').click();
					}
				});

				document.getElementById('user-point-color').addEventListener('change', function(e) {
					userPointColor = e.target.value;
					if (userData.length > 0) {
						userData[0].datasetColor = userPointColor;
						// Pass true to preserve highlights
						updateVisualsOnly();
						
						// Also update the user data array
						userData.forEach(point => {
							point.datasetColor = userPointColor;
						});
					}
				});
				
				document.getElementById('highlight-color').addEventListener('change', function(e) {
					highlightColor = e.target.value;
					// Re-apply highlight if there's a highlighted point
					if (highlightedPoint) {
						const tempPoint = highlightedPoint;
						removeHighlights();
						highlightPoint(tempPoint);
					}
				});
				
				document.getElementById('clear-user-points').addEventListener('click', clearUserPoints);
				
				document.getElementById('disable-scroll').addEventListener('change', function(e) {
					enableScroll = !e.target.checked;
				});
				
				// Set default date to current date
				const today = new Date();
				const todayFormatted = today.toISOString().split('T')[0];
				document.getElementById('date').value = todayFormatted;
				
				// Apply settings button
				document.getElementById('apply-settings').addEventListener('click', function() {
					averageDays = parseInt(document.getElementById('average-days').value);
					tempDepth = document.getElementById('temp-depth').value;
					moistureDepth = document.getElementById('moisture-depth').value;
					updateDataDisplay(false); // false = full reprocessing needed
				});
			
				// Initialize with default settings
				setTimeout(() => {
					if (typeof updateMapPoints === 'function') {
						updateMapPoints();
					}
				}, 200);
				setTimeout(() => {
					updateChartsForTheme();
				}, 400);
			} catch (error) {
				console.error('Error initializing application:', error);
				alert('Error initializing application. Please check the console for details.');
			}
		});
    </script>
</body>
</html>
